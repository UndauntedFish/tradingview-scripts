// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © bjr117

//@version=5
strategy("Trend Following Algorithm - Dev", overlay=true, currency=currency.USD, pyramiding=2, initial_capital = 100000, calc_on_order_fills = true)

//==============================================================================
// FOREX EXCHANGE - Currency Conversion 
// Needed to calculate position sizes for non USD base currency pairs like AUD/JPY or CAD/SGD
//==============================================================================

// Select quote currency
quoteCurrency = syminfo.currency  // gets quote currency of the current pair automatically


// Store currency pair rate quoted against USD (base currency)
usdUSDrate = request.security("USDUSD", timeframe.period, close[1])
gbpUSDrate = request.security("GBPUSD", timeframe.period, close[1])
audUSDrate = request.security("AUDUSD", timeframe.period, close[1])
nzdUSDrate = request.security("NZDUSD", timeframe.period, close[1])
cadUSDrate = request.security("CADUSD", timeframe.period, close[1])
chfUSDrate = request.security("CHFUSD", timeframe.period, close[1])
eurUSDrate = request.security("EURUSD", timeframe.period, close[1])
jpyUSDrate = request.security("JPYUSD", timeframe.period, close[1])
sgdUSDrate = request.security("SGDUSD", timeframe.period, close[1])


// Function to get the currency pair rate quoted against USD
getCurrencyRate(source) =>
    if quoteCurrency == "USD"
        1
    else
        if quoteCurrency == "GBP"
            gbpUSDrate
        else if quoteCurrency == "AUD"
            audUSDrate
        else if quoteCurrency == "NZD"
            nzdUSDrate
        else if quoteCurrency == "CAD"
            cadUSDrate
        else if quoteCurrency == "CHF"
            chfUSDrate
        else if quoteCurrency == "EUR"
            eurUSDrate
        else if quoteCurrency == "JPY"
            jpyUSDrate
        else
            sgdUSDrate


// Put getCurrencyRate() function"s output into a variable
currencyRateMultiplier = getCurrencyRate(ta.tr(true))

//==============================================================================


//==============================================================================
// BACKTEST DATE RANGE - Select Dates
//==============================================================================
// input(defval, title, type, minval, maxval, confirm, step, options, tooltip, inline, group) → input integer

// Date range
startMonth = input.int(title="Start Month", defval=1, minval=1, maxval=12, step=1)
startDay = input.int(title="Start Day", defval=1, minval=1, maxval=31, step=1)
startYear = input.int(title="Start Year", defval=2018, minval=2004, step=1)

endMonth = input.int(title="End Month", defval=1, minval=1, maxval=12, step=1)
endDay = input.int(title="End Day", defval=1, minval=1, maxval=31, step=1)
endYear = input.int(title="End Year", defval=2021, minval=2004, step=1)

startDate = timestamp(startYear, startMonth, startDay, 00, 00, 00)
endDate = timestamp(endYear, endMonth, endDay, 00, 00, 00)
dateWindow() =>
    time >= startDate and time <= endDate ? true : false
//==============================================================================



//==============================================================================
// Function: Calculate a given type of moving average
//==============================================================================
get_ma_out(type, src, len, alma_offset, alma_sigma, kama_fastLength, kama_slowLength, vama_vol_len, vama_do_smth, vama_smth, mf_beta, mf_feedback, mf_z, eit_alpha, ssma_pow, ssma_smooth, rsrma_pw, svama_method, svama_vol_or_volatility, wrma_smooth) =>
    float baseline = 0.0
    
    if type == "SMA  | Simple MA"
        baseline := ta.sma(src, len)

    else if type == "EMA  | Exponential MA"
        baseline := ta.ema(src, len)

    else if type == "DEMA | Double Exponential MA"
        e = ta.ema(src, len)
        baseline := 2 * e - ta.ema(e, len)

    else if type == "TEMA | Triple Exponential MA"
        e = ta.ema(src, len)
        baseline := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)

	else if type == "TMA  | Triangular MA" // by everget
        baseline := ta.sma(ta.sma(src, math.ceil(len / 2)), math.floor(len / 2) + 1)

    else if type == "WMA  | Weighted MA"
        baseline := ta.wma(src, len)

    else if type == "VWMA | Volume-Weighted MA"
        baseline := ta.vwma(src, len)

    else if type == "SMMA | Smoothed MA"
        w = ta.wma(src, len)
        baseline := na(w[1]) ? ta.sma(src, len) : (w[1] * (len - 1) + src) / len

    else if type == "RMA  | Rolling MA"
        baseline := ta.rma(src, len)

    else if type == "HMA  | Hull MA"
        baseline := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))

    else if type == "LSMA | Least Squares MA"
        baseline := ta.linreg(src, len, 0)

    else if type == "Kijun"  //Kijun-sen
        kijun = math.avg(ta.lowest(len), ta.highest(len))
        baseline := kijun

    else if type == "MD   | McGinley Dynamic"
        mg = 0.0
        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow(src / mg[1], 4))
        baseline := mg

	else if type == "JMA  | Jurik MA" // by everget
		DEMAe1 = ta.ema(src, len)
		DEMAe2 = ta.ema(DEMAe1, len)
		baseline := 2 * DEMAe1 - DEMAe2
		
    else if type == "ALMA | Arnaud Legoux MA"
        baseline := ta.alma(src, len, alma_offset, alma_sigma)

    else if type == "VAR  | Vector Autoregression MA"
        valpha = 2 / (len+1)
        vud1   = (src > src[1]) ? (src - src[1]) : 0
        vdd1   = (src < src[1]) ? (src[1] - src) : 0
        vUD    = math.sum(vud1, 9)
        vDD    = math.sum(vdd1, 9)
        vCMO   = nz( (vUD - vDD) / (vUD + vDD) )
        baseline := nz(valpha * math.abs(vCMO) * src) + (1 - valpha * math.abs(vCMO)) * nz(baseline[1])
        
    else if type == "ZLEMA | Zero-Lag Exponential MA" // by HPotter
        xLag     = (len) / 2
        xEMAData = (src + (src - src[xLag]))
        baseline := ta.ema(xEMAData, len)
        
    else if type == "AHMA | Ahrens Moving Average" // by everget
        baseline := nz(baseline[1]) + (src - (nz(baseline[1]) + nz(baseline[len])) / 2) / len 
        
    else if type == "EVWMA | Elastic Volume Weighted MA"
        volumeSum = math.sum(volume, len)
        baseline := ( (volumeSum - volume) * nz(baseline[1]) + volume * src ) / volumeSum
    
    else if type == "SWMA | Sine Weighted MA" // by everget
        sum = 0.0
        weightSum = 0.0
        for i = 0 to len - 1
            weight = math.sin(i * math.pi / (len + 1))
            sum := sum + nz(src[i]) * weight
            weightSum := weightSum + weight
        baseline := sum / weightSum
        
    else if type == "LMA  | Leo MA"
        baseline := 2 * ta.wma(src, len) - ta.sma(src, len)
        
    else if type == "VIDYA | Variable Index Dynamic Average" // by KivancOzbilgic
        mom = ta.change(src)
        upSum = math.sum(math.max(mom, 0), len)
        downSum = math.sum(-math.min(mom, 0), len)
        out = (upSum - downSum) / (upSum + downSum)

        cmo = math.abs(out)
        
        alpha = 2 / (len + 1)
        
        baseline := src * alpha * cmo + nz(baseline[1]) * (1 - alpha * cmo)
    
    else if type == "FRAMA | Fractal Adaptive MA"
        length2 = math.floor(len / 2)
        hh2 = ta.highest(length2)
        ll2 = ta.lowest(length2)
        
        N1 = (hh2 - ll2) / length2
        
        N2 = (hh2[length2] - ll2[length2]) / length2
        
        N3 = (ta.highest(len) - ta.lowest(len)) / len
        
        D = (math.log(N1 + N2) - math.log(N3)) / math.log(2)
        
        factor = math.exp(-4.6 * (D - 1))
        
        baseline := factor * src + (1 - factor) * nz(baseline[1])
    
    else if type == "VMA  | Variable MA" // by LazyBear
        k = 1.0/len
        pdm = math.max((src - src[1]), 0)
        mdm = math.max((src[1] - src), 0)
        
        pdmS  = float(0.0)
        mdmS  = float(0.0)
        pdmS := ((1 - k)*nz(pdmS[1]) + k*pdm)
        mdmS := ((1 - k)*nz(mdmS[1]) + k*mdm)
        
        s = pdmS + mdmS
        pdi = pdmS/s
        mdi = mdmS/s
        
        pdiS  = float(0.0)
        mdiS  = float(0.0)
        pdiS := ((1 - k)*nz(pdiS[1]) + k*pdi)
        mdiS := ((1 - k)*nz(mdiS[1]) + k*mdi)
        
        d = math.abs(pdiS - mdiS)
        s1 = pdiS + mdiS
        
        iS  = float(0.0)
        iS := ((1 - k)*nz(iS[1]) + k*d/s1)
        
        hhv = ta.highest(iS, len) 
        llv = ta.lowest(iS, len) 
        d1 = hhv - llv
        vI = (iS - llv)/d1
        baseline := (1 - k*vI)*nz(baseline[1]) + k*vI*src
    
    else if type == "GMMA | Geometric Mean MA"
        lmean = math.log(src)
        smean = math.sum(lmean, len)
        baseline := math.exp(smean / len)
        
    else if type == "CMA  | Corrective MA" // by everget
        sma = ta.sma(src, len)
        baseline := sma
        v1 = ta.variance(src, len)
        v2 = math.pow(nz(baseline[1], baseline) - baseline, 2)
        v3 = v1 == 0 or v2 == 0 ? 1 : v2 / (v1 + v2)
        
        var tolerance = math.pow(10, -5)
        float err = 1
        
        // Gain Factor
        float kPrev = 1
        float k = 1
        
        for i = 0 to 5000 by 1
            if err > tolerance
                k := v3 * kPrev * (2 - kPrev)
                err := kPrev - k
                kPrev := k
                kPrev
                
        baseline := nz(baseline[1], src) + k * (sma - nz(baseline[1], src))
        
    else if type == "MM   | Moving Median" // by everget
        baseline := ta.percentile_nearest_rank(src, len, 50)
        
    else if type == "QMA  | Quick MA" // by everget
        peak = len / 3
        num = 0.0
        denom = 0.0
         
        for i = 1 to len + 1
            mult = 0.0
            if i <= peak
                mult := i / peak
            else
                mult := (len + 1 - i) / (len + 1 - peak)
            num := num + src[i - 1] * mult
            denom := denom + mult
         
        baseline := (denom != 0.0) ? (num / denom) : src
        
    else if type == "KAMA | Kaufman Adaptive MA" // by everget
        mom = math.abs(ta.change(src, len))
        volatility = math.sum(math.abs(ta.change(src)), len)
        
        // Efficiency Ratio
        er = volatility != 0 ? mom / volatility : 0
        
        fastAlpha = 2 / (kama_fastLength + 1)
        slowAlpha = 2 / (kama_slowLength + 1)
        
        alpha = math.pow(er * (fastAlpha - slowAlpha) + slowAlpha, 2)
        
        baseline := alpha * src + (1 - alpha) * nz(baseline[1], src)
    
    else if type == "VAMA | Volatility Adjusted MA" // by Joris Duyck (JD)
        mid = ta.ema(src, len)
        dev = src - mid
        
        vol_up   = ta.highest(dev, vama_vol_len)
        vol_down = ta.lowest(dev, vama_vol_len)
        
        vama = mid + math.avg(vol_up, vol_down)
        baseline := vama_do_smth ? ta.wma(vama, vama_smth) : vama
    
    else if type == "Modular Filter" // by alexgrover
        //----
        b = 0.0, c = 0.0, os = 0.0, ts = 0.0
        //----
        alpha = 2/(len+1)
        a = mf_feedback ? mf_z*src + (1-mf_z)*nz(baseline[1],src) : src
        //----
        b := a > alpha*a+(1-alpha)*nz(b[1],a) ? a : alpha*a+(1-alpha)*nz(b[1],a)
        c := a < alpha*a+(1-alpha)*nz(c[1],a) ? a : alpha*a+(1-alpha)*nz(c[1],a)
        os := a == b ? 1 : a == c ? 0 : os[1]
        //----
        upper = mf_beta*b+(1-mf_beta)*c
        lower = mf_beta*c+(1-mf_beta)*b 
        baseline := os*upper+(1-os)*lower
    
    else if type == "EIT  | Ehlers Instantaneous Trendline" // by Franklin Moormann (cheatcountry)
        baseline := bar_index < 7 ? (src + (2 * nz(src[1])) + nz(src[2])) / 4 : ((eit_alpha - (math.pow(eit_alpha, 2) / 4)) * src) + (0.5 * math.pow(eit_alpha, 2) * nz(src[1])) - 
         ((eit_alpha - (0.75 * math.pow(eit_alpha, 2))) * nz(src[2])) + (2 * (1 - eit_alpha) * nz(baseline[1])) - (math.pow(1 - eit_alpha, 2) * nz(baseline[2]))
    
    else if type == "ESD  | Ehlers Simple Decycler" // by everget
        // High-pass Filter
        alphaArg = 2 * math.pi / (len * math.sqrt(2))
        
        alpha = 0.0
        alpha := math.cos(alphaArg) != 0
             ? (math.cos(alphaArg) + math.sin(alphaArg) - 1) / math.cos(alphaArg)
             : nz(alpha[1])
        
        hp = 0.0
        hp := math.pow(1 - (alpha / 2), 2) * (src - 2 * nz(src[1]) + nz(src[2])) + 2 * (1 - alpha) * nz(hp[1]) - math.pow(1 - alpha, 2) * nz(hp[2])
    
        baseline := src - hp
    
    else if type == "SSMA  | Shapeshifting MA" // by alexgrover
        //----
        ssma_sum = 0.0
        ssma_sumw = 0.0
        alpha = ssma_smooth ? 2 : 1
        power = ssma_smooth ? ssma_pow - ssma_pow % 2 : ssma_pow
        //----
        for i = 0 to len-1
            x = i/(len-1)
            n = ssma_smooth ? -1 + x*2 : x
            w = 1 - 2*math.pow(n,alpha)/(math.pow(n,power) + 1) 
            ssma_sumw := ssma_sumw + w
            ssma_sum := ssma_sum + src[i] * w
        baseline := ssma_sum/ssma_sumw
        //----
    
    else if type == "RSRMA  | Right Sided Ricker MA" // by alexgrover
        //----
        rsrma_sum = 0.0
        rsrma_sumw = 0.0
        rsrma_width = rsrma_pw/100*len
        for i = 0 to len-1
            w = (1 - math.pow(i/rsrma_width,2))*math.exp(-(i*i/(2*math.pow(rsrma_width,2))))
            rsrma_sumw := rsrma_sumw + w
            rsrma_sum := rsrma_sum + src[i] * w
        baseline := rsrma_sum/rsrma_sumw
        //----

    else if type == "DSWF  | Damped Sine Wave Weighted Filter" // by alexgrover
        //----
        dswf_sum = 0.0
        dswf_sumw = 0.0
        for i = 1 to len
            w = math.sin(2.0*math.pi*i/len)/i
            dswf_sumw := dswf_sumw + w
            dswf_sum := dswf_sum + w*src[i-1]
        //----
        baseline := dswf_sum/dswf_sumw
  
    else if type == "BMF  | Blackman Filter" // by alexgrover
        //----
        bmf_sum = 0.0
        bmf_sumw = 0.0
        for i = 0 to len-1
            k = i/len
            w = 0.42 - 0.5 * math.cos(2 * math.pi * k) + 0.08 * math.cos(4 * math.pi * k)
            bmf_sumw := bmf_sumw + w
            bmf_sum := bmf_sum + w*src[i]
        //----
        baseline := bmf_sum/bmf_sumw

    else if type == "HCF  | Hybrid Convolution Filter" // by alexgrover
        //----
        sum = 0.
        for i = 1 to len
            sgn = .5*(1 - math.cos((i/len)*math.pi))
            sum := sum + (sgn*(nz(baseline[1],src)) + (1 - sgn)*src[i-1]) * ( (.5*(1 - math.cos((i/len)*math.pi))) - (.5*(1 - math.cos(((i-1)/len)*math.pi))) )
        baseline := sum
        //----
    
    else if type == "FIR  | Finite Response Filter" // by alexgrover
        //----
        var b = array.new_float(0)
        if barstate.isfirst
            for i = 0 to len-1
                w = len-i
                array.push(b,w)
        den = array.sum(b)
        //----
        sum = 0.0
        for i = 0 to len-1
            sum := sum + src[i]*array.get(b,i)
        baseline := sum/den
        
    else if type == "FLSMA  | Fisher Least Squares MA" // by alexgrover
        //----
        b = 0.0
        //----
        e = ta.sma(math.abs(src - nz(b[1])),len)
        z = ta.sma(src - nz(b[1],src),len)/e 
        r = (math.exp(2*z) - 1)/(math.exp(2*z) + 1) 
        a = (bar_index - ta.sma(bar_index,len))/ta.stdev(bar_index,len) * r
        b := ta.sma(src,len) + a*ta.stdev(src,len)
        baseline := b
    
    else if type == "SVAMA  | Non-Parametric Volume Adjusted MA" // by alexgrover and bjr117
        //----
        h = 0.0
        l = 0.0
        c = 0.0
        //----
        a = svama_vol_or_volatility == "Volume" ? volume : ta.tr
        h := a > nz(h[1], a) ? a : nz(h[1], a)
        l := a < nz(l[1], a) ? a : nz(l[1], a)
        //----
        b = svama_method == "Max" ? a / h : l / a
        c := b * close + (1 - b) * nz(c[1], close)
        baseline := c

    else if type == "RPMA  | Repulsion MA" // by alexgrover
        baseline := ta.sma(close, len*3) + ta.sma(close, len*2) - ta.sma(close, len)

    else if type == "WRMA  | Well Rounded MA" // by alexgrover
        //----
        alpha = 2/(len+1)
        p1 = wrma_smooth ? len/4 : 1
        p2 = wrma_smooth ? len/4 : len/2
        //----
        a = float(0.0)
        b = float(0.0)
        y = ta.ema(a + b,p1)
        A = src - y
        B = src - ta.ema(y,p2)
        a := nz(a[1]) + alpha*nz(A[1]) 
        b := nz(b[1]) + alpha*nz(B[1])
        baseline := y
    
    else if type == "HLT  | HiLo Trend"
        // Getting the highest highs / lowest lows in the user-inputted slowLength period and fastLength period
        hlt_high = ta.highest(src, len)
        hlt_low  = ta.lowest(src,  len)

        // Calculate the HLT Line
        //   If the source (close, hl2, ...) value is greater than the previous HLT line, let the next HLT line value be the source value.
        baseline := (src > baseline[1]) ? hlt_low : hlt_high
    
    else if type == "T3 | Tillson T3" // by HPotter
        ////////////////////////////////////////////////////////////
        //  Copyright by HPotter v1.0 21/05/2014
        // This indicator plots the moving average described in the January, 1998 issue
        // of S&C, p.57, "Smoothing Techniques for More Accurate Signals", by Tim Tillson.
        // This indicator plots T3 moving average presented in Figure 4 in the article.
        // T3 indicator is a moving average which is calculated according to formula:
        //     T3(n) = GD(GD(GD(n))),
        // where GD - generalized DEMA (Double EMA) and calculating according to this:
        //     GD(n,v) = EMA(n) * (1+v)-EMA(EMA(n)) * v,
        // where "v" is volume factor, which determines how hot the moving average’s response
        // to linear trends will be. The author advises to use v=0.7.
        // When v = 0, GD = EMA, and when v = 1, GD = DEMA. In between, GD is a less aggressive
        // version of DEMA. By using a value for v less than1, trader cure the multiple DEMA
        // overshoot problem but at the cost of accepting some additional phase delay.
        // In filter theory terminology, T3 is a six-pole nonlinear Kalman filter. Kalman
        // filters are ones that use the error — in this case, (time series - EMA(n)) — 
        // to correct themselves. In the realm of technical analysis, these are called adaptive
        // moving averages; they track the time series more aggres-sively when it is making large
        // moves. Tim Tillson is a software project manager at Hewlett-Packard, with degrees in
        // mathematics and computer science. He has privately traded options and equities for 15 years.   
        ////////////////////////////////////////////////////////////
        xe1 = ta.ema(src, len)
        xe2 = ta.ema(xe1, len)
        xe3 = ta.ema(xe2, len)
        xe4 = ta.ema(xe3, len)
        xe5 = ta.ema(xe4, len)
        xe6 = ta.ema(xe5, len)
        b = 0.7
        c1 = -b*b*b
        c2 = 3*b*b+3*b*b*b
        c3 = -6*b*b-3*b-3*b*b*b
        c4 = 1+3*b+b*b*b+3*b*b
        baseline := c1 * xe6 + c2 * xe5 + c3 * xe4 + c4 * xe3

    baseline
//==============================================================================



//==============================================================================
// NUANCES - Inputs
//==============================================================================
// Do you want to select the "one candle rule" in your strategy?
Nau_OCR_Check_Conf = input.bool(title = "One Candle Rule", defval = false)


// Do you want to select the "1x ATR rule" in your strategy?
Nau_ATR_Check_Conf = input.bool(title ="Baseline ATR Rule", defval = false)
Var_ATR_Length     = input.int(title = "Baseline ATR Calculation Length", defval = 14, minval = 1)
Var_ATR_Multiple   = input.float(title = "Baseline ATR Multiple", defval = 1.0, minval = 0.0, step = 0.25)


// Do you want to select the "1 STDEV rule" in your strategy?
Nau_STDEV_Check_Conf = input.bool(title = "Baseline Stdev Rule", defval = false)
Var_STDEV_Length     = input.int(title = "Baseline Stdev Calculation Length", defval = 14, minval = 1)
Var_STDEV_Stdevs     = input.float(title = "Stdev", defval = 1.0, minval = 0.0, step = 0.25)


// Do you want to select the "bridge too far" rule in your strategy (Dillon Grech"s Baseline BTF)?
Nau_BTF_Check_Conf  = input.bool(title="Bridge Too Far (Dillon Grech - Baseline)", defval = false)
// Do you want to select the "bridge too far" rule in your strategy 2.0 (NNFX C1 BTF)?
Nau_BTF2_Check_Conf = input.bool(title="Bridge Too Far (NNFX - C1)", defval = false)
Var_BTF_Period      = input.int(title="Baseline Bridge Too Far: Number of candles", defval = 7, minval = 1)


// EVZ Rules
// Do you want to select EVZ rules in your strategy?
Nau_EVZ_No_Entry_Rule = input.bool(title = "EVZ: No Entry When Below Minimum Normal Threshold", defval = true, inline = "EVZ no entry rule")
Var_EVZ_Minimum       = input.float(title = "", defval = 6.0, minval = 0.0, inline = "EVZ no entry rule")

Nau_EVZ_Avoid_USD = input.bool(title = "EVZ: Avoid USD Pairs When Below Minimum Normal Threshold", defval = false, inline = "EVZ USD rule")
Var_EVZ_Avoid_USD = input.float(title = "", defval = 6.0, minval = 0.0, inline = "EVZ USD rule")

Nau_EVZ_Full_TP = input.bool(title = "EVZ: Take the entire trade off at the ATR Profit Multiple When Below Minimum Normal Threshold", defval = false, inline = "EVZ ATR TP rule")
Var_EVZ_Full_TP = input.float(title = "", defval = 6.0, minval = 0.0, inline = "EVZ ATR TP rule")

EVZrate = request.security("EVZ", timeframe.period, close[1])

Nau_EVZ_No_Entry_Rule_Conf = Nau_EVZ_No_Entry_Rule and syminfo.type == "forex" ? (EVZrate > Var_EVZ_Minimum ? true : false) : true
Nau_EVZ_Avoid_USD_Conf = Nau_EVZ_Avoid_USD and syminfo.type == "forex" and (quoteCurrency == "USD" or syminfo.basecurrency == "USD") ? (EVZrate > Var_EVZ_Avoid_USD ? true : false) : true
Nau_EVZ_Full_TP_Conf = Nau_EVZ_Full_TP and syminfo.type == "forex" ? (EVZrate > Var_EVZ_Full_TP ? false : true) : false
//==============================================================================


//==============================================================================
// Helper function (used below in money management): Calculate positon size
//==============================================================================
get_position_size(initial_capital, percent_risk, atr, atr_sl_multiple, evz_rate, do_evz_lower_risk, evz_lower_risk_percent, evz_lower_risk_floor, evz_lower_risk_ceiling, do_evz_default_risk, evz_default_risk_floor, evz_default_risk_ceiling, do_evz_higher_risk, evz_higher_risk_percent, evz_higher_risk_floor) =>
    // Used to find out how many digits are in the quoted price of the currency pair
    currency_rate_multiplier = getCurrencyRate(ta.tr(true))


    // Determine how much to risk per trade
    risk_percentage = 0.0
    
    if do_evz_lower_risk and evz_rate >= evz_lower_risk_floor and evz_rate < evz_lower_risk_ceiling
        risk_percentage := evz_lower_risk_percent
    else if do_evz_higher_risk and evz_rate >= evz_higher_risk_floor
        risk_percentage := evz_higher_risk_percent
    else if do_evz_default_risk and evz_rate >= evz_default_risk_floor and evz_rate < evz_default_risk_ceiling
        risk_percentage := percent_risk
    else
        risk_percentage := percent_risk


    // Return position size
    math.round(initial_capital * risk_percentage / (atr_sl_multiple * atr) / currency_rate_multiplier)
//==============================================================================


//==============================================================================
// MONEY MANAGEMENT  (ATR) - Get That Bread
//==============================================================================

// Enter initial capital and percentage risk inputs
initialCapital = input(title="Starting Capital", defval=100000, group = "Basic Risk Management Settings")
percentRisk = input.float(title="Default Risk per Trade", defval=0.02, minval=0.001, group = "Basic Risk Management Settings")


// ATR Settings (user input)
atrLength = input(title="ATR Period", defval=14, group = "Basic Risk Management Settings")
atrMulti_Profit = input(title="ATR Profit Multiple", defval=1.0, group = "Basic Risk Management Settings")
atrMulti_Loss = input(title="ATR Loss Multiple", defval=1.5, group = "Basic Risk Management Settings")


// ATR Indicator Source Code
getATR(source, length) =>
    ta.rma(source, length)

truncate(number, decimals) =>
    factor = math.pow(10, decimals)
    int(number * factor) / factor

atr = truncate(getATR(ta.tr(true), atrLength), 5)


// EVZ percent risk nuances
// Lower risk to x% if EVZ is between y and z
Nau_EVZ_Lower_Risk= input.bool(title = "EVZ: Lower Risk to X% if EVZ is >=Y and <Z", defval = false, group = "Nuanced Risk Management Settings")
Var_EVZ_Lower_Risk_Percent = input.float(title = "X", defval = 0.01, minval = 0.001, group = "Nuanced Risk Management Settings", inline = "EVZ Lower Risk")
Var_EVZ_Lower_Risk_Lower_Limit = input.float(title = "Y", defval = 0.0, minval = 0, group = "Nuanced Risk Management Settings", inline = "EVZ Lower Risk")
Var_EVZ_Lower_Risk_Upper_Limit = input.float(title = "Z", defval = 6.0, minval = 0, group = "Nuanced Risk Management Settings", inline = "EVZ Lower Risk")

// Use default risk if EVZ is between y and z
Nau_EVZ_Normal_Risk= input.bool(title = "EVZ: Use Default Risk if EVZ is >=Y and <Z", defval = false, group = "Nuanced Risk Management Settings")
Var_EVZ_Normal_Risk_Lower_Limit = input.float(title = "Y", defval = 6.0, minval = 0, group = "Nuanced Risk Management Settings", inline = "EVZ Default Risk")
Var_EVZ_Normal_Risk_Upper_Limit = input.float(title = "Z", defval = 8.0, minval = 0, group = "Nuanced Risk Management Settings", inline = "EVZ Default Risk")

// Increase risk to x% if EVZ is above y
Nau_EVZ_Higher_Risk= input.bool(title = "EVZ: Increase Risk to X% if EVZ is >=Y and <Z", defval = false, group = "Nuanced Risk Management Settings")
Var_EVZ_Higher_Risk_Percent = input.float(title = "X", defval = 0.03, minval = 0.001, group = "Nuanced Risk Management Settings", inline = "EVZ Higher Risk")
Var_EVZ_Higher_Risk_Lower_Limit = input.float(title = "Y", defval = 8.0, minval = 0, group = "Nuanced Risk Management Settings", inline = "EVZ Higher Risk")


// Calculating position size
positionSize = get_position_size(initialCapital, percentRisk, atr, atrMulti_Loss, EVZrate, Nau_EVZ_Lower_Risk, Var_EVZ_Lower_Risk_Percent, Var_EVZ_Lower_Risk_Lower_Limit, Var_EVZ_Lower_Risk_Upper_Limit, Nau_EVZ_Normal_Risk, Var_EVZ_Normal_Risk_Lower_Limit, Var_EVZ_Normal_Risk_Upper_Limit, Nau_EVZ_Higher_Risk, Var_EVZ_Higher_Risk_Percent, Var_EVZ_Higher_Risk_Lower_Limit)
//math.round(initialCapital * percentRisk / (atrMulti_Loss * atr) / currencyRateMultiplier)

//==============================================================================



//==============================================================================
// INDICATOR 1  (C1) - Trigger / Confirmation
//==============================================================================

// Do you want to enable indicator 1 in your strategy? (user input)
Ind_1_Check_Trig = input(true, title='Indicator 1 (C1) - Trigger')
Ind_1_Check_Conf = input(true, title='Indicator 1 (C1) - Confirmation')


// Directional Volume and Volatility (DVV)
// Inputs
// Volatility Settings
dvv_volatility_period = input.int(title = "DVV Volatility Period", defval = 5, minval = 1, group = "DVV Settings")
dvv_volatility_method = input.string("SMA  | Simple MA", "DVV Volatility smoothing", options=[ "EMA  | Exponential MA",                  "SMA  | Simple MA", 
                                                                     "WMA  | Weighted MA",                     "DEMA | Double Exponential MA", 
                                                                     "TEMA | Triple Exponential MA",           "TMA  | Triangular MA", 
                                                                     "VWMA | Volume-Weighted MA",              "SMMA | Smoothed MA", 
                                                                     "HMA  | Hull MA",                         "LSMA | Least Squares MA", 
                                                                     "Kijun",                                  "MD   | McGinley Dynamic", 
                                                                     "RMA  | Rolling MA",                      "JMA  | Jurik MA", 
                                                                     "ALMA | Arnaud Legoux MA",                "VAR  | Vector Autoregression MA", 
                                                                     "ZLEMA | Zero-Lag Exponential MA",
                                                                     "AHMA | Ahrens Moving Average",           "EVWMA | Elastic Volume Weighted MA",
                                                                     "SWMA | Sine Weighted MA",                "LMA  | Leo MA",
                                                                     "VIDYA | Variable Index Dynamic Average", "FRAMA | Fractal Adaptive MA",
                                                                     "VMA  | Variable MA",                     "GMMA | Geometric Mean MA",
                                                                     "CMA  | Corrective MA",                   "MM   | Moving Median",
                                                                     "QMA  | Quick MA",                        "KAMA | Kaufman Adaptive MA",
                                                                     "VAMA | Volatility Adjusted MA",          "Modular Filter",
                                                                     "EIT  | Ehlers Instantaneous Trendline",  "ESD  | Ehlers Simple Decycler",
                                                                     "SSMA  | Shapeshifting MA",               "RSRMA  | Right Sided Ricker MA",
                                                                     "DSWF  | Damped Sine Wave Weighted Filter", "BMF  | Blackman Filter",
                                                                     "HCF  | Hybrid Convolution Filter",       "FIR  | Finite Response Filter",
                                                                     "FLSMA  | Fisher Least Squares MA",       "SVAMA  | Non-Parametric Volume Adjusted MA",
                                                                     "RPMA  | Repulsion MA",                   "WRMA  | Well Rounded MA"
                                                                     ], group = "DVV Settings")
dvv_use_vol_hist_filter = input.bool(title = "DVV Use Volume Histogram Filter?", defval = false)

// Specific MA settings
volatility_alma_offset = input.float(title = "Offset",    defval = 0.85, step = 0.05, group = "DVV VOLATILITY ALMA Settings")
volatility_alma_sigma  = input.int(title   = "Sigma", defval = 6,                     group = "DVV VOLATILITY ALMA Settings")

volatility_kama_fastLength = input(title = "Fast EMA Length", defval=2,  group = "DVV VOLATILITY KAMA Settings")
volatility_kama_slowLength = input(title = "Slow EMA Length", defval=30, group = "DVV VOLATILITY KAMA Settings")

volatility_vama_vol_len = input.int(title  = "Volatality Length", defval = 51,            group = "DVV VOLATILITY VAMA Settings")
volatility_vama_do_smth = input.bool(title = "Do Smoothing?",     defval = false,         group = "DVV VOLATILITY VAMA Settings")
volatility_vama_smth    = input.int(title  = "Smoothing length",  defval = 5, minval = 1, group = "DVV VOLATILITY VAMA Settings")

volatility_mf_beta     = input.float(title = "Beta",               defval = 0.8, step = 0.1, minval = 0, maxval=1,   group = "DVV VOLATILITY Modular Filter Settings")
volatility_mf_feedback = input.bool(title  = "Feedback?",          defval = false,                                   group = "DVV VOLATILITY Modular Filter Settings")
volatility_mf_z        = input.float(title = "Feedback Weighting", defval = 0.5, step = 0.1, minval = 0, maxval = 1, group = "DVV VOLATILITY Modular Filter Settings")

volatility_eit_alpha = input.float(title = "Alpha", defval = 0.07, step = 0.01, minval = 0.0, group = "DVV VOLATILITY Ehlers Instantaneous Trendline Settings")

volatility_ssma_pow = input.float(title = "Power", defval = 4.0, step = 0.5, minval = 0.0, group = "DVV VOLATILITY SSMA Settings")
volatility_ssma_smooth = input.bool(title = "Smooth", defval = false, group = "DVV VOLATILITY SSMA Settings")

volatility_rsrma_pw = input.float(title = "Percent Width", defval = 60.0, step = 10.0, minval = 0.0, maxval = 100.0, group = "DVV VOLATILITY RSRMA Settings")

volatility_svama_method            = input.string(title = "Max", options=["Max", "Min"], defval = "Max", group = "DVV VOLATILITY SVAMA Settings")
volatility_svama_vol_or_volatility = input.string(title = "Use Volume or Volatility?", options = ["Volume", "Volatility"], defval = "Volatility", group = "DVV VOLATILITY SVAMA Settings")

volatility_wrma_smooth = input.bool(title = "Extra Smoothing?", defval = false, group = "DVV VOLATILITY WRMA Settings")




// Volume Settings
dvv_volume_period = input.int(title = "DVV Volume Period", defval = 14, minval = 1, group = "DVV Settings")
dvv_volume_method = input.string("SMA  | Simple MA", "DVV Volume smoothing", options=[ "EMA  | Exponential MA",                  "SMA  | Simple MA", 
                                                                     "WMA  | Weighted MA",                     "DEMA | Double Exponential MA", 
                                                                     "TEMA | Triple Exponential MA",           "TMA  | Triangular MA", 
                                                                     "VWMA | Volume-Weighted MA",              "SMMA | Smoothed MA", 
                                                                     "HMA  | Hull MA",                         "LSMA | Least Squares MA", 
                                                                     "Kijun",                                  "MD   | McGinley Dynamic", 
                                                                     "RMA  | Rolling MA",                      "JMA  | Jurik MA", 
                                                                     "ALMA | Arnaud Legoux MA",                "VAR  | Vector Autoregression MA", 
                                                                     "ZLEMA | Zero-Lag Exponential MA",
                                                                     "AHMA | Ahrens Moving Average",           "EVWMA | Elastic Volume Weighted MA",
                                                                     "SWMA | Sine Weighted MA",                "LMA  | Leo MA",
                                                                     "VIDYA | Variable Index Dynamic Average", "FRAMA | Fractal Adaptive MA",
                                                                     "VMA  | Variable MA",                     "GMMA | Geometric Mean MA",
                                                                     "CMA  | Corrective MA",                   "MM   | Moving Median",
                                                                     "QMA  | Quick MA",                        "KAMA | Kaufman Adaptive MA",
                                                                     "VAMA | Volatility Adjusted MA",          "Modular Filter",
                                                                     "EIT  | Ehlers Instantaneous Trendline",  "ESD  | Ehlers Simple Decycler",
                                                                     "SSMA  | Shapeshifting MA",               "RSRMA  | Right Sided Ricker MA",
                                                                     "DSWF  | Damped Sine Wave Weighted Filter", "BMF  | Blackman Filter",
                                                                     "HCF  | Hybrid Convolution Filter",       "FIR  | Finite Response Filter",
                                                                     "FLSMA  | Fisher Least Squares MA",       "SVAMA  | Non-Parametric Volume Adjusted MA",
                                                                     "RPMA  | Repulsion MA",                   "WRMA  | Well Rounded MA"
                                                                     ], group = "DVV Settings")

// Specific MA settings
volume_alma_offset = input.float(title = "Offset",    defval = 0.85, step = 0.05, group = "DVV VOLUME ALMA Settings")
volume_alma_sigma  = input.int(title   = "Sigma", defval = 6,                     group = "DVV VOLUME ALMA Settings")

volume_kama_fastLength = input(title = "Fast EMA Length", defval=2,  group = "DVV VOLUME KAMA Settings")
volume_kama_slowLength = input(title = "Slow EMA Length", defval=30, group = "DVV VOLUME KAMA Settings")

volume_vama_vol_len = input.int(title  = "Volatality Length", defval = 51,            group = "DVV VOLUME VAMA Settings")
volume_vama_do_smth = input.bool(title = "Do Smoothing?",     defval = false,         group = "DVV VOLUME VAMA Settings")
volume_vama_smth    = input.int(title  = "Smoothing length",  defval = 5, minval = 1, group = "DVV VOLUME VAMA Settings")

volume_mf_beta     = input.float(title = "Beta",               defval = 0.8, step = 0.1, minval = 0, maxval=1,   group = "DVV VOLUME Modular Filter Settings")
volume_mf_feedback = input.bool(title  = "Feedback?",          defval = false,                                   group = "DVV VOLUME Modular Filter Settings")
volume_mf_z        = input.float(title = "Feedback Weighting", defval = 0.5, step = 0.1, minval = 0, maxval = 1, group = "DVV VOLUME Modular Filter Settings")

volume_eit_alpha = input.float(title = "Alpha", defval = 0.07, step = 0.01, minval = 0.0, group = "DVV VOLUME Ehlers Instantaneous Trendline Settings")

volume_ssma_pow = input.float(title = "Power", defval = 4.0, step = 0.5, minval = 0.0, group = "DVV VOLUME SSMA Settings")
volume_ssma_smooth = input.bool(title = "Smooth", defval = false, group = "DVV VOLUME SSMA Settings")

volume_rsrma_pw = input.float(title = "Percent Width", defval = 60.0, step = 10.0, minval = 0.0, maxval = 100.0, group = "DVV VOLUME RSRMA Settings")

volume_svama_method            = input.string(title = "Max", options=["Max", "Min"], defval = "Max", group = "DVV VOLUME SVAMA Settings")
volume_svama_vol_or_volatility = input.string(title = "Use Volume or Volatility?", options = ["Volume", "Volatility"], defval = "Volatility", group = "DVV VOLUME SVAMA Settings")

volume_wrma_smooth = input.bool(title = "Extra Smoothing?", defval = false, group = "DVV VOLUME WRMA Settings")



// Zone Settings
dvv_zone_period = input.int(title = "DVV Zone Period", defval = 14, minval = 1, group = "DVV Settings")
dvv_zone_method = input.string("SMA  | Simple MA", "DVV Zone smoothing", options=[ "EMA  | Exponential MA",                  "SMA  | Simple MA", 
                                                                     "WMA  | Weighted MA",                     "DEMA | Double Exponential MA", 
                                                                     "TEMA | Triple Exponential MA",           "TMA  | Triangular MA", 
                                                                     "VWMA | Volume-Weighted MA",              "SMMA | Smoothed MA", 
                                                                     "HMA  | Hull MA",                         "LSMA | Least Squares MA", 
                                                                     "Kijun",                                  "MD   | McGinley Dynamic", 
                                                                     "RMA  | Rolling MA",                      "JMA  | Jurik MA", 
                                                                     "ALMA | Arnaud Legoux MA",                "VAR  | Vector Autoregression MA", 
                                                                     "ZLEMA | Zero-Lag Exponential MA",
                                                                     "AHMA | Ahrens Moving Average",           "EVWMA | Elastic Volume Weighted MA",
                                                                     "SWMA | Sine Weighted MA",                "LMA  | Leo MA",
                                                                     "VIDYA | Variable Index Dynamic Average", "FRAMA | Fractal Adaptive MA",
                                                                     "VMA  | Variable MA",                     "GMMA | Geometric Mean MA",
                                                                     "CMA  | Corrective MA",                   "MM   | Moving Median",
                                                                     "QMA  | Quick MA",                        "KAMA | Kaufman Adaptive MA",
                                                                     "VAMA | Volatility Adjusted MA",          "Modular Filter",
                                                                     "EIT  | Ehlers Instantaneous Trendline",  "ESD  | Ehlers Simple Decycler",
                                                                     "SSMA  | Shapeshifting MA",               "RSRMA  | Right Sided Ricker MA",
                                                                     "DSWF  | Damped Sine Wave Weighted Filter", "BMF  | Blackman Filter",
                                                                     "HCF  | Hybrid Convolution Filter",       "FIR  | Finite Response Filter",
                                                                     "FLSMA  | Fisher Least Squares MA",       "SVAMA  | Non-Parametric Volume Adjusted MA",
                                                                     "RPMA  | Repulsion MA",                   "WRMA  | Well Rounded MA"
                                                                     ], group = "DVV Settings")

// Specific MA settings
zone_alma_offset = input.float(title = "Offset",    defval = 0.85, step = 0.05, group = "DVV ZONE ALMA Settings")
zone_alma_sigma  = input.int(title   = "Sigma", defval = 6,                     group = "DVV ZONE ALMA Settings")

zone_kama_fastLength = input(title = "Fast EMA Length", defval=2,  group = "DVV ZONE KAMA Settings")
zone_kama_slowLength = input(title = "Slow EMA Length", defval=30, group = "DVV ZONE KAMA Settings")

zone_vama_vol_len = input.int(title  = "Volatality Length", defval = 51,            group = "DVV ZONE VAMA Settings")
zone_vama_do_smth = input.bool(title = "Do Smoothing?",     defval = false,         group = "DVV ZONE VAMA Settings")
zone_vama_smth    = input.int(title  = "Smoothing length",  defval = 5, minval = 1, group = "DVV ZONE VAMA Settings")

zone_mf_beta     = input.float(title = "Beta",               defval = 0.8, step = 0.1, minval = 0, maxval=1,   group = "DVV ZONE Modular Filter Settings")
zone_mf_feedback = input.bool(title  = "Feedback?",          defval = false,                                   group = "DVV ZONE Modular Filter Settings")
zone_mf_z        = input.float(title = "Feedback Weighting", defval = 0.5, step = 0.1, minval = 0, maxval = 1, group = "DVV ZONE Modular Filter Settings")

zone_eit_alpha = input.float(title = "Alpha", defval = 0.07, step = 0.01, minval = 0.0, group = "DVV ZONE Ehlers Instantaneous Trendline Settings")

zone_ssma_pow = input.float(title = "Power", defval = 4.0, step = 0.5, minval = 0.0, group = "DVV ZONE SSMA Settings")
zone_ssma_smooth = input.bool(title = "Smooth", defval = false, group = "DVV ZONE SSMA Settings")

zone_rsrma_pw = input.float(title = "Percent Width", defval = 60.0, step = 10.0, minval = 0.0, maxval = 100.0, group = "DVV ZONE RSRMA Settings")

zone_svama_method            = input.string(title = "Max", options=["Max", "Min"], defval = "Max", group = "DVV ZONE SVAMA Settings")
zone_svama_vol_or_volatility = input.string(title = "Use Volume or Volatility?", options = ["Volume", "Volatility"], defval = "Volatility", group = "DVV ZONE SVAMA Settings")

zone_wrma_smooth = input.bool(title = "Extra Smoothing?", defval = false, group = "DVV ZONE WRMA Settings")


// Calculating DVV lines
dvv_zeroline = get_ma_out(dvv_zone_method, hl2, dvv_zone_period, zone_alma_offset, zone_alma_sigma, zone_kama_fastLength, zone_kama_slowLength, zone_vama_vol_len, zone_vama_do_smth, zone_vama_smth, zone_mf_beta, zone_mf_feedback, zone_mf_z, zone_eit_alpha, zone_ssma_pow, zone_ssma_smooth, zone_rsrma_pw, zone_svama_method, zone_svama_vol_or_volatility, zone_wrma_smooth)
val = get_ma_out(dvv_volatility_method, close, dvv_volatility_period, volatility_alma_offset, volatility_alma_sigma, volatility_kama_fastLength, volatility_kama_slowLength, volatility_vama_vol_len, volatility_vama_do_smth, volatility_vama_smth, volatility_mf_beta, volatility_mf_feedback, volatility_mf_z, volatility_eit_alpha, volatility_ssma_pow, volatility_ssma_smooth, volatility_rsrma_pw, volatility_svama_method, volatility_svama_vol_or_volatility, volatility_wrma_smooth) - dvv_zeroline
znUp = get_ma_out(dvv_zone_method, high, dvv_zone_period, zone_alma_offset, zone_alma_sigma, zone_kama_fastLength, zone_kama_slowLength, zone_vama_vol_len, zone_vama_do_smth, zone_vama_smth, zone_mf_beta, zone_mf_feedback, zone_mf_z, zone_eit_alpha, zone_ssma_pow, zone_ssma_smooth, zone_rsrma_pw, zone_svama_method, zone_svama_vol_or_volatility, zone_wrma_smooth) - dvv_zeroline
znDn = get_ma_out(dvv_zone_method, low, dvv_zone_period, zone_alma_offset, zone_alma_sigma, zone_kama_fastLength, zone_kama_slowLength, zone_vama_vol_len, zone_vama_do_smth, zone_vama_smth, zone_mf_beta, zone_mf_feedback, zone_mf_z, zone_eit_alpha, zone_ssma_pow, zone_ssma_smooth, zone_rsrma_pw, zone_svama_method, zone_svama_vol_or_volatility, zone_wrma_smooth) - dvv_zeroline
vol      = close > open ? volume : -volume
volSm = get_ma_out(dvv_volume_method, vol, dvv_volume_period, volume_alma_offset, volume_alma_sigma, volume_kama_fastLength, volume_kama_slowLength, volume_vama_vol_len, volume_vama_do_smth, volume_vama_smth, volume_mf_beta, volume_mf_feedback, volume_mf_z, volume_eit_alpha, volume_ssma_pow, volume_ssma_smooth, volume_rsrma_pw, volume_svama_method, volume_svama_vol_or_volatility, volume_wrma_smooth)


// DVV Up Volatility / Down Volatility Signals
up_vol_trig = ta.crossover(val,znUp)
dn_vol_trig = ta.crossunder(val,znDn)

up_vol_conf = val > znUp
dn_vol_conf = val < znDn


// DVV Up Volatility / Down Volatility Alerts
if up_vol_trig
    alert("Volatility broke upper zone",alert.freq_once_per_bar_close)
else if dn_vol_trig
    alert("Volatility broke lower zone",alert.freq_once_per_bar_close)


// DVV Coloring and Plotting
valColor = val > znUp ? color.green : color.red
volColor = dvv_use_vol_hist_filter ? (volSm > 0 ? color.blue : volSm < 0 ? color.orange : color.gray) : color.gray

//plot(val, title="Volatility", style=plot.style_columns, color=valColor)
//plot(znUp, title="Volume Up", style=plot.style_columns, color=volColor)
//plot(znDn, title="Volume Dn", style=plot.style_columns, color=volColor)

dvv_L_trig = ta.crossover(val, znUp)
dvv_S_trig = ta.crossunder(val, znDn)

dvv_L_conf = val > znUp
dvv_S_conf = val < znDn


// Long and short triggers
Ind_1_L_Trig = Ind_1_Check_Trig ? (dvv_L_trig ? true : false) : false
Ind_1_S_Trig = Ind_1_Check_Trig ? (dvv_S_trig ? true : false) : false


// Long and short confirmations
Ind_1_L_Conf = Ind_1_Check_Trig ? (dvv_L_conf ? true : false) : true
Ind_1_S_Conf = Ind_1_Check_Trig ? (dvv_S_conf ? true : false) : true


//------------------------------------------------------------------------------
// Bridge too far counter 2.0 (DO NOT REMOVE WHILE SWAPPING C1 INDICATORS)
//------------------------------------------------------------------------------
Count_Btf2  = float(0.0)

// If price crosses baseline, set the counter to zero. Otherwise, keep incrementing the counter until another baseline cross.
Count_Btf2 := (Ind_1_L_Trig or Ind_1_S_Trig) ? 0 : Count_Btf2[1] + 1

// If the count of the Bridge too Far is greater than 7 (or user defined value), do not enter a trade.
Ind_Btf2_Conf = ( Ind_1_Check_Conf and Nau_BTF2_Check_Conf ) ? ( Count_Btf2 <= Var_BTF_Period ? true : false ) : true
//==============================================================================



//==============================================================================
// INDICATOR 2  (C2) - Confirmation 2
//==============================================================================
// Do you want to enable indicator 2 in your strategy? (user input)
Ind_2_Check_Conf = input(true, title='Indicator 2 (Confirmation 2) - Trigger')


// Kalman Filter Indicator
kf_src       = input.source(title = "Kalman Filter Source", defval = hlcc4)
kf_sharpness = input.float(title = "Kalman Filter Sharpness", defval = 1.0, minval = 0, step = 0.1)
kf_K         = input.float(title = "Kalman Filter K", defval = 2.0, minval = 0, step = 0.1)

greencolor = color.lime
redcolor   = color.red

velocity = 0.0
kfilt    = 0.0

Distance  = kf_src - nz(kfilt[1], kf_src)
Error     = nz(kfilt[1], kf_src) + Distance * math.sqrt(kf_sharpness*kf_K/ 100)
velocity := nz(velocity[1], 0) + Distance*kf_K / 100
kfilt    := Error + velocity

plot(Ind_2_Check_Conf ? kfilt : na, color=velocity > 0 ? greencolor : redcolor, linewidth = 2)


// Long and short trigger
Ind_2_L_Conf = Ind_2_Check_Conf ? (velocity > 0 ? true : false) : true
Ind_2_S_Conf = Ind_2_Check_Conf ? (velocity < 0 ? true : false) : true
//==============================================================================



//==============================================================================
// INDICATOR 3  (VOL) - Confirmation
//==============================================================================
// Do you want to enable indicator 3 in your strategy? (user input)
Ind_3_Check_Conf = input(true, title='Indicator 3 (Volume/Volatility/Momentum) - Confirmation')

// Braid Filter Indicator - Copyright © Robert Hill, 2006
// Inputs
// Main settings
bf_ma_type = input.string("EMA  | Exponential MA", "MA Type", options=[ "EMA  | Exponential MA",                  "SMA  | Simple MA", 
                                                                     "WMA  | Weighted MA",                     "DEMA | Double Exponential MA", 
                                                                     "TEMA | Triple Exponential MA",           "TMA  | Triangular MA", 
                                                                     "VWMA | Volume-Weighted MA",              "SMMA | Smoothed MA", 
                                                                     "HMA  | Hull MA",                         "LSMA | Least Squares MA", 
                                                                     "Kijun",                                  "MD   | McGinley Dynamic", 
                                                                     "RMA  | Rolling MA",                      "JMA  | Jurik MA", 
                                                                     "ALMA | Arnaud Legoux MA",                "VAR  | Vector Autoregression MA", 
                                                                     "ZLEMA | Zero-Lag Exponential MA",        "T3 | Tillson T3",
                                                                     "AHMA | Ahrens Moving Average",           "EVWMA | Elastic Volume Weighted MA",
                                                                     "SWMA | Sine Weighted MA",                "LMA  | Leo MA",
                                                                     "VIDYA | Variable Index Dynamic Average", "FRAMA | Fractal Adaptive MA",
                                                                     "VMA  | Variable MA",                     "GMMA | Geometric Mean MA",
                                                                     "CMA  | Corrective MA",                   "MM   | Moving Median",
                                                                     "QMA  | Quick MA",                        "KAMA | Kaufman Adaptive MA",
                                                                     "VAMA | Volatility Adjusted MA",          "Modular Filter",
                                                                     "EIT  | Ehlers Instantaneous Trendline",  "ESD  | Ehlers Simple Decycler",
                                                                     "SSMA  | Shapeshifting MA",               "RSRMA  | Right Sided Ricker MA",
                                                                     "DSWF  | Damped Sine Wave Weighted Filter", "BMF  | Blackman Filter",
                                                                     "HCF  | Hybrid Convolution Filter",       "FIR  | Finite Response Filter",
                                                                     "FLSMA  | Fisher Least Squares MA",       "SVAMA  | Non-Parametric Volume Adjusted MA",
                                                                     "RPMA  | Repulsion MA",                   "WRMA  | Well Rounded MA",
                                                                     "HLT  | HiLo Trend"
                                                                     ], group = "Main Braid Filter Settings")
bf_ma_src = input.source(title = "MA Source", defval = close, group = "Main Braid Filter Settings")
bf_len_1 = input.int(title = "Fast Source Price MA Length", defval = 3, minval = 1, group = "Main Braid Filter Settings")
bf_len_2 = input.int(title = "Open Price MA Length", defval = 7, minval = 1, group = "Main Braid Filter Settings")
bf_len_3 = input.int(title = "Slow Source Price MA Length", defval = 14, minval = 1, group = "Main Braid Filter Settings")
bf_filter_strength = input.float(title = "Filter Strength", defval = 40.0, minval = 1.0, step = 1.0, group = "Main Braid Filter Settings")
bf_atr_len = input.int(title = "ATR Length", defval = 14, minval = 1, group = "Main Braid Filter Settings")


// Display settings
bf_color_bars = input.bool(title = "Color Bars?", defval = false, group = "Braid Filter Display Settings")
bf_show_sigs = input.bool(title = "Show Signals?", defval = false, group = "Braid Filter Display Settings")


// Specific MA Settings
bf_ma1_alma_offset = input.float(title = "Offset",    defval = 0.85, step = 0.05, group = "Braid Filter ALMA Settings")
bf_ma1_alma_sigma  = input.int(title   = "Sigma", defval = 6,                     group = "Braid Filter ALMA Settings")

bf_ma1_kama_fastLength = input(title = "Fast EMA Length", defval=2,  group = "Braid Filter KAMA Settings")
bf_ma1_kama_slowLength = input(title = "Slow EMA Length", defval=30, group = "Braid Filter KAMA Settings")

bf_ma1_vama_vol_len = input.int(title  = "Volatality Length", defval = 51,            group = "Braid Filter VAMA Settings")
bf_ma1_vama_do_smth = input.bool(title = "Do Smoothing?",     defval = false,         group = "Braid Filter VAMA Settings")
bf_ma1_vama_smth    = input.int(title  = "Smoothing length",  defval = 5, minval = 1, group = "Braid Filter VAMA Settings")

bf_ma1_mf_beta     = input.float(title = "Beta",               defval = 0.8, step = 0.1, minval = 0, maxval=1,   group = "Braid Filter Modular Filter Settings")
bf_ma1_mf_feedback = input.bool(title  = "Feedback?",          defval = false,                                   group = "Braid Filter Modular Filter Settings")
bf_ma1_mf_z        = input.float(title = "Feedback Weighting", defval = 0.5, step = 0.1, minval = 0, maxval = 1, group = "Braid Filter Modular Filter Settings")

bf_ma1_eit_alpha = input.float(title = "Alpha", defval = 0.07, step = 0.01, minval = 0.0, group = "Braid Filter Ehlers Instantaneous Trendline Settings")

bf_ssma1_pow = input.float(title = "Power", defval = 4.0, step = 0.5, minval = 0.0, group = "Braid Filter SSMA Settings")
bf_ssma1_smooth = input.bool(title = "Smooth", defval = false, group = "Braid Filter SSMA Settings")

bf_rsrma1_pw = input.float(title = "Percent Width", defval = 60.0, step = 10.0, minval = 0.0, maxval = 100.0, group = "Braid Filter RSRMA Settings")

bf_svama1_method            = input.string(title = "Max", options=["Max", "Min"], defval = "Max", group = "Braid Filter SVAMA Settings")
bf_svama1_vol_or_volatility = input.string(title = "Use Volume or Volatility?", options = ["Volume", "Volatility"], defval = "Volatility", group = "Braid Filter SVAMA Settings")

bf_wrma1_smooth = input.bool(title = "Extra Smoothing?", defval = false, group = "Braid Filter WRMA Settings")


// Calculating the Braid Filter
// Calculating an average of the source price with a low lookback period
bf_fast_src_ma = get_ma_out(bf_ma_type, bf_ma_src, bf_len_1, bf_ma1_alma_offset, bf_ma1_alma_sigma, bf_ma1_kama_fastLength, bf_ma1_kama_slowLength, bf_ma1_vama_vol_len, bf_ma1_vama_do_smth, bf_ma1_vama_smth, bf_ma1_mf_beta, bf_ma1_mf_feedback, bf_ma1_mf_z, bf_ma1_eit_alpha, bf_ssma1_pow, bf_ssma1_smooth, bf_rsrma1_pw, bf_svama1_method, bf_svama1_vol_or_volatility, bf_wrma1_smooth)
// Calculating an average of the open price with a low lookback period
bf_open_ma     = get_ma_out(bf_ma_type, open,      bf_len_2, bf_ma1_alma_offset, bf_ma1_alma_sigma, bf_ma1_kama_fastLength, bf_ma1_kama_slowLength, bf_ma1_vama_vol_len, bf_ma1_vama_do_smth, bf_ma1_vama_smth, bf_ma1_mf_beta, bf_ma1_mf_feedback, bf_ma1_mf_z, bf_ma1_eit_alpha, bf_ssma1_pow, bf_ssma1_smooth, bf_rsrma1_pw, bf_svama1_method, bf_svama1_vol_or_volatility, bf_wrma1_smooth)
// Calculating an average of the source price with a high lookback period
bf_slow_src_ma = get_ma_out(bf_ma_type, bf_ma_src, bf_len_3, bf_ma1_alma_offset, bf_ma1_alma_sigma, bf_ma1_kama_fastLength, bf_ma1_kama_slowLength, bf_ma1_vama_vol_len, bf_ma1_vama_do_smth, bf_ma1_vama_smth, bf_ma1_mf_beta, bf_ma1_mf_feedback, bf_ma1_mf_z, bf_ma1_eit_alpha, bf_ssma1_pow, bf_ssma1_smooth, bf_rsrma1_pw, bf_svama1_method, bf_svama1_vol_or_volatility, bf_wrma1_smooth)


// Determining whether the average source price MA is greater than the average open price, and then determining whether the highest one out of those two is greater than the slow average source price.
bf_ma_max = math.max(math.max(bf_fast_src_ma, bf_open_ma), bf_slow_src_ma)
// Determining whether the average source price MA is greater than the average open price, and then determining whether the highest one out of those two is greater than the slow average source price.
bf_ma_min = math.min(math.min(bf_fast_src_ma, bf_open_ma), bf_slow_src_ma)

// Calculating the braid filter's histogram by taking the difference between the highest average price out of the three calculated above, and subtracting it by the lowest average price out of the three calculated above.
bf_histo  = bf_ma_max - bf_ma_min
// Calculating the braid filter's "deadzone" line by multiplying the average true range by the filter strength (a constant inputted by the user; higher values increase the strictness of the filter), and then dividing that resulting value by 100 to make the filter fit the histogram.
bf_filter = ta.atr(bf_atr_len) * bf_filter_strength / 100.0


// Calculating the Braid Filter's signals
is_histo_above_filter = bf_histo > bf_filter
is_histo_bar_bullish = bf_fast_src_ma > bf_open_ma
is_histo_bar_bearish = bf_fast_src_ma < bf_open_ma

// True if the histogram bar switches to green and is above the filter, false otherwise
bf_L_trig = is_histo_above_filter and (ta.crossover(bf_fast_src_ma, bf_open_ma) or (ta.crossover(bf_histo, bf_filter) and is_histo_bar_bullish))
// True if the histogram bar switches to red and is above the filter, false otherwise
bf_S_trig = is_histo_above_filter and (ta.crossunder(bf_fast_src_ma, bf_open_ma) or (ta.crossover(bf_histo, bf_filter) and is_histo_bar_bearish))

// True if the histogram bar switches to and remains green and is above the filter, false otherwise
bf_L_conf = is_histo_above_filter and is_histo_bar_bullish
// True if the histogram bar switches to and remains green and is above the filter, false otherwise
bf_S_conf = is_histo_above_filter and is_histo_bar_bearish


// Long and short confirmation
Ind_3_L_Conf = Ind_3_Check_Conf ? (bf_L_conf  ? true : false) : true
Ind_3_S_Conf = Ind_3_Check_Conf ? (bf_S_conf ? true : false) : true
//==============================================================================


//==============================================================================
// Nuance - Marobozu and Combi Volume Signals
//==============================================================================
Nau_MZBU_Check_Conf = input.bool(false, title = "Enable Marobozu Volume Nuance")
Nau_CMBI_Check_Conf = input.bool(false, title = "Enable Combi Volume Nuance")
show_mzbu     = input.bool(title  = "Show Marobozu Signals?", defval = true, group = "Marobozu Detection Settings")
mzbu_max_hlcr = input.float(title = "High/Low : Close Min Ratio",   defval = 0.2, minval = 0, step = 0.005, group = "Marobozu Detection Settings")
mzbu_atr_filt = input.bool(title = "Do ATR Filter?", defval = false, group = "Marobozu Detection Settings")
mzbu_atr_len  = input.int(title = "ATR Filter Length", defval = 14, minval = 1, group = "Marobozu Detection Settings")
show_cmbi     = input.bool(title  = "Show Combi Signals?",    defval = true, group = "Combi Detection Settings")
cmbi_atr_filt = input.bool(title = "Do ATR Filter?", defval = false, group = "Combi Detection Settings")
cmbi_atr_len  = input.int(title = "ATR Filter Length", defval = 14, minval = 1, group = "Combi Detection Settings")


// Function: Given price data and a high/close or low/close ratio, find out if the current candle is a marobozu
is_marobozu(o, h, l, c, max_hlcr) =>
    is_bullish = c > o ? true : false
    is_bearish = c < o ? true : false
    current_hlcr = float(0.0)
    
    if is_bullish
        current_hlcr := (h - c) / (h - l)
    else if is_bearish
        current_hlcr := (c - l) / (h - l)
    
    if current_hlcr <= max_hlcr
        true
    else
        false


// Function: Given price data and a high/close or low/close ratio, find out if the current candle is a combi
is_combi(o, h, l, c) =>
    // Inside bar ohlc
    current_bar_o = open
    current_bar_h = high
    current_bar_l = low
    current_bar_c = close
    // Previous bar ohlc
    prev_bar_o = open[1]
    prev_bar_h = high[1]
    prev_bar_l = low[1]
    prev_bar_c = close[1]

    // Is the current bar bullish or bearish?
    current_bar_is_bullish = current_bar_c > current_bar_o
    // Is the previous bar bullish or bearish?
    prev_bar_is_bullish = prev_bar_c > prev_bar_o

    // If the current candle is an inside candle, check if the previous candle was an outside candle. If so, return true
    prev_bar_height = math.abs(prev_bar_h - prev_bar_l)
    current_bar_body_height = math.abs(current_bar_c - current_bar_o)

    // If the height of the current bar"s body is less than the height of the previous bar
    if prev_bar_height > current_bar_body_height
        if current_bar_is_bullish
            if prev_bar_h > current_bar_c and prev_bar_l > current_bar_o
                true
        else
            if prev_bar_h > current_bar_o and current_bar_c > prev_bar_l
                true
    else
        false


// Plot text labels indicating all marobozu and combi candles on the chart
candle_is_bullish_mzbu = Nau_MZBU_Check_Conf and Ind_3_Check_Conf ? mzbu_atr_filt ? (ta.tr > ta.atr(mzbu_atr_len) ? is_marobozu(open, high, low, close, mzbu_max_hlcr) and close > open : false)                : is_marobozu(open, high, low, close, mzbu_max_hlcr) and close > open                : false
candle_is_bearish_mzbu = Nau_MZBU_Check_Conf and Ind_3_Check_Conf ? mzbu_atr_filt ? (ta.tr > ta.atr(mzbu_atr_len) ? is_marobozu(open, high, low, close, mzbu_max_hlcr) and close < open : false)                : is_marobozu(open, high, low, close, mzbu_max_hlcr) and close < open                : false
candle_is_combi        = Nau_CMBI_Check_Conf and Ind_3_Check_Conf ? cmbi_atr_filt ? (ta.tr > ta.atr(cmbi_atr_len) ? (is_combi(open, high, low, close) or is_combi(open[1], high[1], low[1], close[1])) : false) : (is_combi(open, high, low, close) or is_combi(open[1], high[1], low[1], close[1])) : false

// Plot text labels indicating all marobozu and combi candles on the chart
plotshape(Ind_3_Check_Conf and not Ind_3_L_Conf and show_mzbu and candle_is_bullish_mzbu,                        title = "Bullish Marobozu Label", color = color.green, textcolor = color.green, text = "Marobozu", style = shape.triangleup,   location = location.belowbar, size = size.tiny)
plotshape(Ind_3_Check_Conf and not Ind_3_S_Conf and show_mzbu and candle_is_bearish_mzbu,                        title = "Bearish Marobozu Label", color = color.red,   textcolor = color.red,   text = "Marobozu", style = shape.triangledown, location = location.abovebar, size = size.tiny)
plotshape(Ind_3_Check_Conf and not Ind_3_L_Conf and show_cmbi and candle_is_combi and close > ta.sma(close, 20), title = "Bullish Combi Label",    color = color.gray,  textcolor = color.gray,  text = "Combi",    style = shape.triangleup,   location = location.belowbar, size = size.tiny)
plotshape(Ind_3_Check_Conf and not Ind_3_S_Conf and show_cmbi and candle_is_combi and close < ta.sma(close, 20), title = "Bearish Combi Label",    color = color.gray,  textcolor = color.gray,  text = "Combi",    style = shape.triangledown, location = location.abovebar, size = size.tiny)
//==============================================================================


//==============================================================================
// INDICATOR 4  (BL) - Trigger / Confirmation
// name your output line"s variable to "baseline" for it to work with bridge too far
//==============================================================================
// Do you want to enable indicator 1 in your strategy? (user input)
Ind_4_Check_Conf = input(true, title="Indicator 4 (Baseline) - Confirmation")
Ind_4_Conf_Type = input.string(title = "Indicator 4 (Baseline) - Confirmation Type", defval = "Price Position Confirmation", options = ["Price Position Confirmation", "Slope Direction Confirmation"])
Ind_4_Check_BLC_Trig = input(false, title="Indicator 4 (Baseline) - Price Crossover Trigger")
Ind_4_Check_BLS_Trig = input(false, title="Indicator 4 (Baseline) - Slope Change Trigger")

// Moving Average (MA) Source Code
bl_ma_type = input.string("T3 | Tillson T3", "MA Type", options=[ "EMA  | Exponential MA",                  "SMA  | Simple MA", 
                                                                     "WMA  | Weighted MA",                     "DEMA | Double Exponential MA", 
                                                                     "TEMA | Triple Exponential MA",           "TMA  | Triangular MA", 
                                                                     "VWMA | Volume-Weighted MA",              "SMMA | Smoothed MA", 
                                                                     "HMA  | Hull MA",                         "LSMA | Least Squares MA", 
                                                                     "Kijun",                                  "MD   | McGinley Dynamic", 
                                                                     "RMA  | Rolling MA",                      "JMA  | Jurik MA", 
                                                                     "ALMA | Arnaud Legoux MA",                "VAR  | Vector Autoregression MA", 
                                                                     "ZLEMA | Zero-Lag Exponential MA",        "T3 | Tillson T3",
                                                                     "AHMA | Ahrens Moving Average",           "EVWMA | Elastic Volume Weighted MA",
                                                                     "SWMA | Sine Weighted MA",                "LMA  | Leo MA",
                                                                     "VIDYA | Variable Index Dynamic Average", "FRAMA | Fractal Adaptive MA",
                                                                     "VMA  | Variable MA",                     "GMMA | Geometric Mean MA",
                                                                     "CMA  | Corrective MA",                   "MM   | Moving Median",
                                                                     "QMA  | Quick MA",                        "KAMA | Kaufman Adaptive MA",
                                                                     "VAMA | Volatility Adjusted MA",          "Modular Filter",
                                                                     "EIT  | Ehlers Instantaneous Trendline",  "ESD  | Ehlers Simple Decycler",
                                                                     "SSMA  | Shapeshifting MA",               "RSRMA  | Right Sided Ricker MA",
                                                                     "DSWF  | Damped Sine Wave Weighted Filter", "BMF  | Blackman Filter",
                                                                     "HCF  | Hybrid Convolution Filter",       "FIR  | Finite Response Filter",
                                                                     "FLSMA  | Fisher Least Squares MA",       "SVAMA  | Non-Parametric Volume Adjusted MA",
                                                                     "RPMA  | Repulsion MA",                   "WRMA  | Well Rounded MA",
                                                                     "HLT  | HiLo Trend"
                                                                     ], group = "General MA Settings")

bl_ma_len = input.int(5, minval=1, title="Length", group = "Baseline MA Settings")
bl_ma_src = input.source(close, title="Source", group = "Baseline MA Settings")

// Specific ma settings
bl_alma_offset = input.float(title = "Offset",    defval = 0.85, step = 0.05, group = "Baseline ALMA Settings")
bl_alma_sigma  = input.int(title   = "Sigma", defval = 6,                     group = "Baseline ALMA Settings")

bl_kama_fastLength = input(title = "Fast EMA Length", defval=2,  group = "Baseline KAMA Settings")
bl_kama_slowLength = input(title = "Slow EMA Length", defval=30, group = "Baseline KAMA Settings")

bl_vama_vol_len = input.int(title  = "Volatality Length", defval = 51,            group = "Baseline VAMA Settings")
bl_vama_do_smth = input.bool(title = "Do Smoothing?",     defval = false,         group = "Baseline VAMA Settings")
bl_vama_smth    = input.int(title  = "Smoothing length",  defval = 5, minval = 1, group = "Baseline VAMA Settings")

bl_mf_beta     = input.float(title = "Beta",               defval = 0.8, step = 0.1, minval = 0, maxval=1,   group = "Baseline Modular Filter Settings")
bl_mf_feedback = input.bool(title  = "Feedback?",          defval = false,                                   group = "Baseline Modular Filter Settings")
bl_mf_z        = input.float(title = "Feedback Weighting", defval = 0.5, step = 0.1, minval = 0, maxval = 1, group = "Baseline Modular Filter Settings")

bl_eit_alpha = input.float(title = "Alpha", defval = 0.07, step = 0.01, minval = 0.0, group = "Ehlers Instantaneous Trendline Settings")

bl_ssma_pow = input.float(title = "Power", defval = 4.0, step = 0.5, minval = 0.0, group = "SSMA Settings")
bl_ssma_smooth = input.bool(title = "Smooth", defval = false, group = "SSMA Settings")

bl_rsrma_pw = input.float(title = "Percent Width", defval = 60.0, step = 10.0, minval = 0.0, maxval = 100.0, group = "RSRMA Settings")

bl_svama_method            = input.string(title = "Max", options=["Max", "Min"], defval = "Max", group = "SVAMA Settings")
bl_svama_vol_or_volatility = input.string(title = "Use Volume or Volatility?", options = ["Volume", "Volatility"], defval = "Volatility", group = "SVAMA Settings")

bl_wrma_smooth = input.bool(title = "Extra Smoothing?", defval = false, group = "WRMA Settings")


// Plotting the baseline
baseline = get_ma_out(bl_ma_type, bl_ma_src, bl_ma_len, bl_alma_offset, bl_alma_sigma, bl_kama_fastLength, bl_kama_slowLength, bl_vama_vol_len, bl_vama_do_smth, bl_vama_smth, bl_mf_beta, bl_mf_feedback, bl_mf_z, bl_eit_alpha, bl_ssma_pow, bl_ssma_smooth, bl_rsrma_pw, bl_svama_method, bl_svama_vol_or_volatility, bl_wrma_smooth)
plot(Ind_4_Check_Conf or Ind_4_Check_BLC_Trig or Ind_4_Check_BLS_Trig ? baseline : na, linewidth = 2, color = #000000)


// Long and short confirmation
Ind_4_L_Conf_BLC = close > baseline        ? true : false
Ind_4_S_Conf_BLC = close < baseline        ? true : false
Ind_4_L_Conf_BLS = ta.roc(baseline, 1) > 0 ? true : false
Ind_4_S_Conf_BLS = ta.roc(baseline, 1) < 0 ? true : false

Ind_4_L_Conf = Ind_4_Check_Conf ? (Ind_4_Conf_Type == "Price Position Confirmation" ? Ind_4_L_Conf_BLC : Ind_4_L_Conf_BLS) : true
Ind_4_S_Conf = Ind_4_Check_Conf ? (Ind_4_Conf_Type == "Price Position Confirmation" ? Ind_4_S_Conf_BLC : Ind_4_S_Conf_BLS) : true


// Long and short trigger
Ind_4_L_Trig_BLC = Ind_4_Check_BLC_Trig and ta.crossover(close,  baseline)        ? true : false
Ind_4_S_Trig_BLC = Ind_4_Check_BLC_Trig and ta.crossunder(close, baseline)        ? true : false
Ind_4_L_Trig_BLS = Ind_4_Check_BLS_Trig and ta.crossover(ta.roc(baseline,  1), 0) ? true : false
Ind_4_S_Trig_BLS = Ind_4_Check_BLS_Trig and ta.crossunder(ta.roc(baseline, 1), 0) ? true : false

Ind_4_L_Trig = Ind_4_L_Trig_BLC or Ind_4_L_Trig_BLS
Ind_4_S_Trig = Ind_4_S_Trig_BLC or Ind_4_S_Trig_BLS

//------------------------------------------------------------------------------
// Baseline ATR Rule Code (DO NOT REMOVE WHILE SWAPPING BASELINE INDICATORS)
//------------------------------------------------------------------------------
// Plot baseline
plot(Ind_4_Check_Conf ? baseline : na, "MA", linewidth=2, color=color.new(#000000, 0))


// If enabled, plot the ATR bands around the baseline
atr_bands_width = truncate(getATR(ta.tr(true), Var_ATR_Length), 5) * Var_ATR_Multiple
plot(Ind_4_Check_Conf and Nau_ATR_Check_Conf ? baseline + atr_bands_width : na, title="MA ATR Upper Band", linewidth=1, color=color.new(#000000, 80))
plot(Ind_4_Check_Conf and Nau_ATR_Check_Conf ? baseline - atr_bands_width : na, title="MA ATR Lower Band", linewidth=1, color=color.new(#000000, 80))

// Confirmation long and short signals for 1xATR 
Ind_4_L_Conf_ATR = (Ind_4_Check_Conf and Nau_ATR_Check_Conf) ? close < (baseline + (Var_ATR_Multiple*atr)) ? true : false : true
Ind_4_S_Conf_ATR = (Ind_4_Check_Conf and Nau_ATR_Check_Conf) ? close > (baseline - (Var_ATR_Multiple*atr)) ? true : false : true


// If enabled, plot the STDEV bands around the baseline
stdev_bands_size = ta.stdev(close, Var_STDEV_Length, true) * Var_STDEV_Stdevs
plot(Ind_4_Check_Conf and Nau_STDEV_Check_Conf ? baseline + stdev_bands_size : na, title="MA STDEV Upper Band", linewidth=1, color=color.new(#000000, 80))
plot(Ind_4_Check_Conf and Nau_STDEV_Check_Conf ? baseline - stdev_bands_size : na, title="MA STDEV Lower Band", linewidth=1, color=color.new(#000000, 80))

// Confirmation long and short signals for 1xSTDEV 
Ind_4_L_Conf_STDEV = (Ind_4_Check_Conf and Nau_STDEV_Check_Conf) ? close < (baseline + stdev_bands_size) ? true : false : true
Ind_4_S_Conf_STDEV = (Ind_4_Check_Conf and Nau_STDEV_Check_Conf) ? close > (baseline - stdev_bands_size) ? true : false : true
//------------------------------------------------------------------------------
// Bridge too far counter 1.0 (DO NOT REMOVE WHILE SWAPPING BASELINE INDICATORS)
//------------------------------------------------------------------------------
Count_Btf  = float(0.0)

// If price crosses baseline, set the counter to zero. Otherwise, keep incrementing the counter until another baseline cross.
Count_Btf := ta.cross(close, baseline) ? 0 : Count_Btf[1] + 1

// If the count of the Bridge too Far is greater than 7 (or user defined value), do not enter a trade.
Ind_Btf_Conf = ( Ind_4_Check_Conf and Nau_BTF_Check_Conf ) ? ( Count_Btf <= Var_BTF_Period ? true : false ) : true
//==============================================================================



//==============================================================================
// INDICATOR 5  (EX) - Exit
//==============================================================================

//------------------------------------------------------------------------------
// General Exit Indicator Settings
//------------------------------------------------------------------------------
// Do you want to select Indicator 5 in your strategy?
Ind_5_Check_Exit = input(true, title = "Indicator 5 (Exit) - Trigger")

// Select if you want a static stop loss or a trailing stop loss.
Exit_Type = input.string(defval="Trailing Exit", title="Exit Type", options=["Static", "Trailing Exit"])

// Select what kind of trailing exit you"d like 
trailing_exit_type = input.string("Exit indicator #1", title = "Trailing Exit Type", options = ["Opposite C1 signal", "Exit indicator #1", "Split Exit: Exit indicator #1 + Opposite C1 Signal", "Split Exit: Exit indicator #1 + Exit indicator #2", "Split Exit: Exit indicator #1 + ATR Trailing Stop"])

// Stop Loss Handicap
sl_handicap_input = input.float(title = "Stop Loss Handicap Amount (pipettes)", defval = 1.0, minval = 0.0)
sl_handicap = quoteCurrency == "JPY" ? sl_handicap_input * 0.001 : sl_handicap_input * 0.00001
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Exit Indicator #1: Fisher Transform
//------------------------------------------------------------------------------
// Inputs
fish_len        = input.int(title    = "Fisher Transform Length",       defval = 10,   minval = 0,   step = 1)
fish_src        = input.source(title = "Fisher Transform Source",       defval = hl2)
fish_norm1      = input.float(title  = "Normalization Constant 1",      defval = 0.25, minval = 0.0, step = 0.1)
fish_norm2      = input.float(title  = "Normalization Constant 2",      defval = 0.50, minval = 0.0, step = 0.1)
fish_do_signals = input.bool(title   = 'Show Crossover Signals?', defval = false)


// Calculate the highest high and lowest low within the fish_len period
highest_high = ta.highest(fish_src, fish_len)
lowest_low   = ta.lowest(fish_src,  fish_len)


// Calculate value1, which is a function used to nomalize price within the range of fish_len
value1  = float(0.0)
value1 := fish_norm1 * 2 * ( (fish_src - lowest_low) / (highest_high - lowest_low) - 0.5 ) + fish_norm2 * nz(value1[1])

if value1 > 0.9999
    value1 := 0.9999
else if value1 < -0.9999
    value1 := -0.9999


// Calculate the Fisher Transformation of the source (fish_src). 
// Also calculate the Trigger Line, which is the previous Fisher Transformation value.
fish  = float(0.0)
fish := 0.25 * math.log( (1 + value1) / (1 - value1) ) + 0.5 * nz(fish[1])

trigger  = float(0.0)
trigger := nz(fish[1])
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Exit Indicator #1 Signals
//------------------------------------------------------------------------------
Ind_5_L_Exit_1 = Ind_5_Check_Exit ? ta.crossunder(fish, trigger) ? true : false : false
Ind_5_S_Exit_1 = Ind_5_Check_Exit ? ta.crossover(fish, trigger)  ? true : false : false
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Exit Indicator #2: SSL+
// The second exit indicator exits the second trade, if the first trade makes it to profit.
//------------------------------------------------------------------------------
// Inputs
ssl_src      = input.source(close, title = "SSL Source")
ssl_ma1_type = input.string('EMA  | Exponential MA', 'MA Type', options=[ 'EMA  | Exponential MA',                  'SMA  | Simple MA', 
                                                                     'WMA  | Weighted MA',                     'DEMA | Double Exponential MA', 
                                                                     'TEMA | Triple Exponential MA',           'TMA  | Triangular MA', 
                                                                     'VWMA | Volume-Weighted MA',              'SMMA | Smoothed MA', 
                                                                     'HMA  | Hull MA',                         'LSMA | Least Squares MA', 
                                                                     'Kijun',                                  'MD   | McGinley Dynamic', 
                                                                     'RMA  | Rolling MA',                      'JMA  | Jurik MA', 
                                                                     'ALMA | Arnaud Legoux MA',                'VAR  | Vector Autoregression MA', 
                                                                     'ZLEMA | Zero-Lag Exponential MA',
                                                                     'AHMA | Ahrens Moving Average',           'EVWMA | Elastic Volume Weighted MA',
                                                                     'SWMA | Sine Weighted MA',                'LMA  | Leo MA',
                                                                     'VIDYA | Variable Index Dynamic Average', 'FRAMA | Fractal Adaptive MA',
                                                                     'VMA  | Variable MA',                     'GMMA | Geometric Mean MA',
                                                                     'CMA  | Corrective MA',                   'MM   | Moving Median',
                                                                     'QMA  | Quick MA',                        'KAMA | Kaufman Adaptive MA',
                                                                     'VAMA | Volatility Adjusted MA',          'Modular Filter',
                                                                     'EIT  | Ehlers Instantaneous Trendline',  'ESD  | Ehlers Simple Decycler',
                                                                     'SSMA  | Shapeshifting MA',               'RSRMA  | Right Sided Ricker MA',
                                                                     'DSWF  | Damped Sine Wave Weighted Filter', 'BMF  | Blackman Filter',
                                                                     'HCF  | Hybrid Convolution Filter',       'FIR  | Finite Response Filter',
                                                                     'FLSMA  | Fisher Least Squares MA',       'SVAMA  | Non-Parametric Volume Adjusted MA',
                                                                     'RPMA  | Repulsion MA',                   'WRMA  | Well Rounded MA'
                                                                     ], group = 'MA #1 Settings')
ssl_ma2_type = input.string('EMA  | Exponential MA', 'MA Type', options=[ 'EMA  | Exponential MA',                  'SMA  | Simple MA', 
                                                                     'WMA  | Weighted MA',                     'DEMA | Double Exponential MA', 
                                                                     'TEMA | Triple Exponential MA',           'TMA  | Triangular MA', 
                                                                     'VWMA | Volume-Weighted MA',              'SMMA | Smoothed MA', 
                                                                     'HMA  | Hull MA',                         'LSMA | Least Squares MA', 
                                                                     'Kijun',                                  'MD   | McGinley Dynamic', 
                                                                     'RMA  | Rolling MA',                      'JMA  | Jurik MA', 
                                                                     'ALMA | Arnaud Legoux MA',                'VAR  | Vector Autoregression MA', 
                                                                     'ZLEMA | Zero-Lag Exponential MA',
                                                                     'AHMA | Ahrens Moving Average',           'EVWMA | Elastic Volume Weighted MA',
                                                                     'SWMA | Sine Weighted MA',                'LMA  | Leo MA',
                                                                     'VIDYA | Variable Index Dynamic Average', 'FRAMA | Fractal Adaptive MA',
                                                                     'VMA  | Variable MA',                     'GMMA | Geometric Mean MA',
                                                                     'CMA  | Corrective MA',                   'MM   | Moving Median',
                                                                     'QMA  | Quick MA',                        'KAMA | Kaufman Adaptive MA',
                                                                     'VAMA | Volatility Adjusted MA',          'Modular Filter',
                                                                     'EIT  | Ehlers Instantaneous Trendline',  'ESD  | Ehlers Simple Decycler',
                                                                     'SSMA  | Shapeshifting MA',               'RSRMA  | Right Sided Ricker MA',
                                                                     'DSWF  | Damped Sine Wave Weighted Filter', 'BMF  | Blackman Filter',
                                                                     'HCF  | Hybrid Convolution Filter',       'FIR  | Finite Response Filter',
                                                                     'FLSMA  | Fisher Least Squares MA',       'SVAMA  | Non-Parametric Volume Adjusted MA',
                                                                     'RPMA  | Repulsion MA',                   'WRMA  | Well Rounded MA'
                                                                     ], group = 'MA #2 Settings')

ssl_ma1_len        = input.int(title    = 'MA #1 Length', defval = 10, minval = 1,  group = 'SSL MA #1 Settings')
ssl_ma1_src        = input.source(title = 'MA #1 Source', defval = high,            group = 'SSL MA #1 Settings')
ssl_ma2_len        = input.int(title    = 'MA #2 Length', defval = 10, minval = 1, group = 'SSL MA #2 Settings')
ssl_ma2_src        = input.source(title = 'MA #2 Source', defval = low,             group = 'SSL MA #2 Settings')

// Specific indicator settings
ssl_ma1_alma_offset = input.float(title = "MA #1: Offset",    defval = 0.85, step = 0.05, group = 'SSL ALMA Settings')
ssl_ma1_alma_sigma  = input.int(title   = 'MA #1: Sigma', defval = 6,                     group = 'SSL ALMA Settings')
ssl_ma2_alma_offset = input.float(title = "MA #2: Offset",    defval = 0.85, step = 0.05, group = 'SSL ALMA Settings')
ssl_ma2_alma_sigma  = input.int(title   = 'MA #2: Sigma', defval = 6,                     group = 'SSL ALMA Settings')

ssl_ma1_kama_fastLength = input(title = 'MA #1: Fast EMA Length', defval=2,  group = 'SSL KAMA Settings')
ssl_ma1_kama_slowLength = input(title = 'MA #1: Slow EMA Length', defval=30, group = 'SSL KAMA Settings')
ssl_ma2_kama_fastLength = input(title = 'MA #2: Fast EMA Length', defval=2,  group = 'SSL KAMA Settings')
ssl_ma2_kama_slowLength = input(title = 'MA #2: Slow EMA Length', defval=30, group = 'SSL KAMA Settings')

ssl_ma1_vama_vol_len = input.int(title  = 'MA #1: Volatality Length', defval = 51,            group = 'SSL VAMA Settings')
ssl_ma1_vama_do_smth = input.bool(title = 'MA #1: Do Smoothing?',     defval = false,         group = 'SSL VAMA Settings')
ssl_ma1_vama_smth    = input.int(title  = 'MA #1: Smoothing length',  defval = 5, minval = 1, group = 'SSL VAMA Settings')
ssl_ma2_vama_vol_len = input.int(title  = 'MA #2: Volatality Length', defval = 51,            group = 'SSL VAMA Settings')
ssl_ma2_vama_do_smth = input.bool(title = 'MA #2: Do Smoothing?',     defval = false,         group = 'SSL VAMA Settings')
ssl_ma2_vama_smth    = input.int(title  = 'MA #2: Smoothing length',  defval = 5, minval = 1, group = 'SSL VAMA Settings')

ssl_ma1_mf_beta     = input.float(title = 'MA #1: Beta',               defval = 0.8, step = 0.1, minval = 0, maxval=1,   group = 'SSL Modular Filter Settings')
ssl_ma1_mf_feedback = input.bool(title  = 'MA #1: Feedback?',          defval = false,                                   group = 'SSL Modular Filter Settings')
ssl_ma1_mf_z        = input.float(title = 'MA #1: Feedback Weighting', defval = 0.5, step = 0.1, minval = 0, maxval = 1, group = 'SSL Modular Filter Settings')
ssl_ma2_mf_beta     = input.float(title = 'MA #2: Beta',               defval = 0.8, step = 0.1, minval = 0, maxval=1,   group = 'SSL Modular Filter Settings')
ssl_ma2_mf_feedback = input.bool(title  = 'MA #2: Feedback?',          defval = false,                                   group = 'SSL Modular Filter Settings')
ssl_ma2_mf_z        = input.float(title = 'MA #2: Feedback Weighting', defval = 0.5, step = 0.1, minval = 0, maxval = 1, group = 'SSL Modular Filter Settings')

ssl_ma1_eit_alpha = input.float(title = 'MA #1: Alpha', defval = 0.07, step = 0.01, minval = 0.0, group = 'SSL Ehlers Instantaneous Trendline Settings')
ssl_ma2_eit_alpha = input.float(title = 'MA #2: Alpha', defval = 0.07, step = 0.01, minval = 0.0, group = 'SSL Ehlers Instantaneous Trendline Settings')

ssl_ssma1_pow = input.float(title = 'Power', defval = 4.0, step = 0.5, minval = 0.0, group = 'SSL SSMA Settings')
ssl_ssma1_smooth = input.bool(title = 'Smooth', defval = false, group = 'SSL SSMA Settings')
ssl_ssma2_pow = input.float(title = 'Power', defval = 4.0, step = 0.5, minval = 0.0, group = 'SSL SSMA Settings')
ssl_ssma2_smooth = input.bool(title = 'Smooth', defval = false, group = 'SSL SSMA Settings')

ssl_rsrma1_pw = input.float(title = "Percent Width", defval = 60.0, step = 10.0, minval = 0.0, maxval = 100.0, group = 'SSL RSRMA Settings')
ssl_rsrma2_pw = input.float(title = "Percent Width", defval = 60.0, step = 10.0, minval = 0.0, maxval = 100.0, group = 'SSL RSRMA Settings')

ssl_svama1_method            = input.string(title = 'Max', options=['Max', 'Min'], defval = 'Max', group = 'SSL SVAMA Settings')
ssl_svama2_method            = input.string(title = 'Max', options=['Max', 'Min'], defval = 'Max', group = 'SSL SVAMA Settings')
ssl_svama1_vol_or_volatility = input.string(title = 'Use Volume or Volatility?', options = ['Volume', 'Volatility'], defval = 'Volatility', group = 'SSL SVAMA Settings')
ssl_svama2_vol_or_volatility = input.string(title = 'Use Volume or Volatility?', options = ['Volume', 'Volatility'], defval = 'Volatility', group = 'SSL SVAMA Settings')

ssl_wrma1_smooth = input.bool(title = "Extra Smoothing?", defval = false, group = 'SSL WRMA Settings')
ssl_wrma2_smooth = input.bool(title = "Extra Smoothing?", defval = false, group = 'SSL WRMA Settings')


// Calculate the SSL moving averages
ssl_ma1 = get_ma_out(ssl_ma1_type, ssl_ma1_src, ssl_ma1_len, ssl_ma1_alma_offset, ssl_ma1_alma_sigma, ssl_ma1_kama_fastLength, ssl_ma1_kama_slowLength, ssl_ma1_vama_vol_len, ssl_ma1_vama_do_smth, ssl_ma1_vama_smth, ssl_ma1_mf_beta, ssl_ma1_mf_feedback, ssl_ma1_mf_z, ssl_ma1_eit_alpha, ssl_ssma1_pow, ssl_ssma1_smooth, ssl_rsrma1_pw, ssl_svama1_method, ssl_svama1_vol_or_volatility, ssl_wrma1_smooth)
ssl_ma2 = get_ma_out(ssl_ma2_type, ssl_ma2_src, ssl_ma2_len, ssl_ma2_alma_offset, ssl_ma2_alma_sigma, ssl_ma2_kama_fastLength, ssl_ma2_kama_slowLength, ssl_ma2_vama_vol_len, ssl_ma2_vama_do_smth, ssl_ma2_vama_smth, ssl_ma2_mf_beta, ssl_ma2_mf_feedback, ssl_ma2_mf_z, ssl_ma2_eit_alpha, ssl_ssma2_pow, ssl_ssma2_smooth, ssl_rsrma2_pw, ssl_svama2_method, ssl_svama2_vol_or_volatility, ssl_wrma2_smooth)


// Helper function: calculate the SSL
//  ssl_ma1: The first SSL moving average
//  ssl_ma2: The second SSL moving average
//  ssl_src: The price that the SSL channel is determined by
calculate_ssl(ssl_ma1, ssl_ma2, ssl_src) =>
    hlv       = int(0)
    hlv      := ssl_src > ssl_ma1 ? 1 : (ssl_src < ssl_ma2 ? -1 : hlv[1])
    ssl_down  = float(0.0)
    ssl_up    = float(0.0)
    ssl_down := hlv < 0 ? ssl_ma1: ssl_ma2
    ssl_up   := hlv < 0 ? ssl_ma2 : ssl_ma1
    [ssl_up, ssl_down]


// Calculate and plot the ssl up and down channels
[ssl_up, ssl_down] = calculate_ssl(ssl_ma1, ssl_ma2, ssl_src)

plot((Ind_5_Check_Exit and trailing_exit_type == "Split Exit: Exit indicator #1 + Exit indicator #2") ? ssl_up   : na, title = "SSL Line #1", color = color.green, linewidth = 2)
plot((Ind_5_Check_Exit and trailing_exit_type == "Split Exit: Exit indicator #1 + Exit indicator #2") ? ssl_down : na, title = "SSL Line #2", color = color.red,   linewidth = 2)
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Exit Indicator #2 Signals
//------------------------------------------------------------------------------
Ind_5_L_Exit_2 = Ind_5_Check_Exit ? (ta.crossunder(ssl_up, ssl_down) ? true : false) : false
Ind_5_S_Exit_2 = Ind_5_Check_Exit ? (ta.crossover(ssl_up, ssl_down)  ? true : false) : false
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Baseline Cross Exit Signals (DO NOT OVERWRITE WHILE PASTING IN EXIT INDIS ABOVE)
//------------------------------------------------------------------------------
Ind_5_Check_Exit_BLC = input.bool(title = "Indicator 5 (Baseline Exit) - Price Cross Trigger",  defval = false)
Ind_5_When_Exit_BLC = input.string(title = "When to use BLC exit?", defval = "Anytime", options = ["Anytime", "Before 1xATR TP is reached", "After 1xATR TP is reached"])
Ind_5_Check_Exit_BLS = input.bool(title = "Indicator 5 (Baseline Exit) - Slope Change Trigger", defval = false)
Ind_5_When_Exit_BLS = input.string(title = "When to use BLS exit?", defval = "Anytime", options = ["Anytime", "Before 1xATR TP is reached", "After 1xATR TP is reached"])

Ind_5_L_Exit_BLC = Ind_5_Check_Exit_BLC and ta.crossunder(close, baseline)        ? true : false
Ind_5_S_Exit_BLC = Ind_5_Check_Exit_BLC and ta.crossover(close, baseline)         ? true : false
Ind_5_L_Exit_BLS = Ind_5_Check_Exit_BLS and ta.crossunder(ta.roc(baseline, 1), 0) ? true : false
Ind_5_S_Exit_BLS = Ind_5_Check_Exit_BLS and ta.crossover(ta.roc(baseline, 1), 0)  ? true : false

Ind_5_L_Exit_BL = Ind_5_L_Exit_BLC or Ind_5_L_Exit_BLS
Ind_5_S_Exit_BL = Ind_5_S_Exit_BLC or Ind_5_S_Exit_BLS
//------------------------------------------------------------------------------

//==============================================================================



//==============================================================================
// INDICATOR 6  (CON) - Continuation Trades
//==============================================================================
// Do you want to select Indicator 6 in your strategy?
Ind_6_Check_Trig = input.bool(title = "Indicator 6 (Continuation) - Trigger", defval = false)

// Which indicator to use to get continuation signals? C1, Exit indicator(s), or a dedicated continuation indicator?
Ind_6_Cont_Method = input.string(title = "Which indicator to use as continuation?", defval = "Continuation", options = ["C1", "Exit 1", "Exit 2", "Continuation", "BLC", "BLS"])

// Which filter to use for continuation indicators?
Ind_6_Filter_Method = input.string(title = "Which filter to use for continuations?", defval = "Baseline", options = ["Baseline", "C1"])
Ind_6_Check_For_Trade = input.bool(title = "Only take continuations after a valid C1 trade", defval = true)

// Which rules to ignore for continuation signals?
Ind_6_Cont_BLATR_Rule = input.bool(title = "Ignore BL ATR Rule for continuations?", defval = true)
Ind_6_Cont_Vol_Rule = input.bool(title = "Ignore Volume indicator for continuations?", defval = true)
Ind_6_Cont_EVZ_Rule = input.bool(title = "Ignore EVZ no trade rule for continuations?", defval = false)
Ind_6_Cont_C2_Rule = input.bool(title = "Ignore C2 for continuations?", defval = false)



// Continuation trade counter
// ASTFL
count_cont  = float(0.0)
// If price crosses baseline, set the counter to zero. Otherwise if we're in a trade, set the counter to 1. Then once that trade is completely closed, set the counter to 2.
count_cont := (Ind_6_Filter_Method == "Baseline" ? ta.cross(close, baseline) : (Ind_1_L_Trig or Ind_1_S_Trig)) ? 0 : Ind_6_Check_For_Trade ? (strategy.position_size != 0 ? 1 : strategy.position_size[1] != 0 and strategy.position_size == 0 ? 2 : count_cont[1]) : (2)

Ind_6_Look_For_Conts = Ind_6_Check_Trig ? (count_cont == 2 ? true : false) : false






Ind_6_L_Trig = Ind_6_Check_Trig ? ta.crossover(0, 0) ? true : false : false
Ind_6_S_Trig = Ind_6_Check_Trig ? ta.crossunder(0, 0) ? true : false : false
//==============================================================================



//==============================================================================
// ENTRY CONDITIONS - Submit Orders
//==============================================================================

// Long Condition 1 - C1 Cross - Combine all indicator long signals here
longCondition1  = strategy.position_size <= 0 and Nau_EVZ_No_Entry_Rule_Conf and Nau_EVZ_Avoid_USD_Conf and (Ind_1_L_Trig or (Ind_1_L_Trig[1] and close < close[1] and Nau_OCR_Check_Conf)) and Ind_2_L_Conf and (Ind_3_L_Conf or (not Ind_3_L_Conf and (candle_is_bullish_mzbu or candle_is_combi))) and Ind_4_L_Conf and Ind_4_L_Conf_ATR and Ind_4_L_Conf_STDEV and Ind_Btf_Conf and Ind_Btf2_Conf
shortCondition1 = strategy.position_size >= 0 and Nau_EVZ_No_Entry_Rule_Conf and Nau_EVZ_Avoid_USD_Conf and (Ind_1_S_Trig or (Ind_1_S_Trig[1] and close > close[1] and Nau_OCR_Check_Conf)) and Ind_2_S_Conf and (Ind_3_S_Conf or (not Ind_3_S_Conf and (candle_is_bearish_mzbu or candle_is_combi))) and Ind_4_S_Conf and Ind_4_S_Conf_ATR and Ind_4_S_Conf_STDEV and Ind_Btf_Conf and Ind_Btf2_Conf
plotshape(longCondition1,  color=color.new(color.green, 75), style=shape.triangleup,   location=location.bottom, size=size.tiny)
plotshape(shortCondition1, color=color.new(color.red, 75),   style=shape.triangledown, location=location.bottom, size=size.tiny)


// Long Condition 2 - Baseline Cross - Combine all indicator long signals here
longCondition2  = strategy.position_size <= 0 and Nau_EVZ_No_Entry_Rule_Conf and Nau_EVZ_Avoid_USD_Conf and Ind_1_L_Conf and Ind_2_L_Conf and (Ind_3_L_Conf or (not Ind_3_L_Conf and (candle_is_bullish_mzbu or candle_is_combi))) and (Ind_4_L_Trig or (Ind_4_L_Trig[1] and close < close[1] and Nau_OCR_Check_Conf)) and Ind_4_L_Conf_ATR and Ind_4_L_Conf_STDEV and Ind_Btf_Conf and Ind_Btf2_Conf
shortCondition2 = strategy.position_size >= 0 and Nau_EVZ_No_Entry_Rule_Conf and Nau_EVZ_Avoid_USD_Conf and Ind_1_S_Conf and Ind_2_S_Conf and (Ind_3_S_Conf or (not Ind_3_S_Conf and (candle_is_bearish_mzbu or candle_is_combi))) and (Ind_4_S_Trig or (Ind_4_S_Trig[1] and close > close[1] and Nau_OCR_Check_Conf)) and Ind_4_S_Conf_ATR and Ind_4_S_Conf_STDEV and Ind_Btf_Conf and Ind_Btf2_Conf
plotshape(longCondition2,  color=color.new(color.green, 75), style=shape.xcross,   location=location.bottom, size=size.tiny)
plotshape(shortCondition2, color=color.new(color.red, 75),   style=shape.xcross, location=location.bottom, size=size.tiny)

// Long Condition 2 - Continuation Trades - Combine all indicator long signals here
longCondition3  = strategy.position_size <= 0 and Ind_6_Look_For_Conts and Nau_EVZ_Avoid_USD_Conf and Ind_1_L_Conf and (Ind_6_Cont_EVZ_Rule ? true : Nau_EVZ_No_Entry_Rule_Conf) and (Ind_6_Cont_Method == "BLC" ? Ind_4_L_Trig_BLC : Ind_6_Cont_Method == "BLS" ? Ind_4_L_Trig_BLS : Ind_6_Cont_Method == "C1" ? Ind_1_L_Trig : Ind_6_Cont_Method == "Exit 1" ? Ind_5_S_Exit_1 : Ind_6_Cont_Method == "Exit 2" ? Ind_5_S_Exit_2 : Ind_6_Cont_Method == "Continuation" ? Ind_6_L_Trig : false) and (Ind_6_Cont_C2_Rule ? true : Ind_2_L_Conf) and (Ind_6_Cont_Vol_Rule ? true : (Ind_3_L_Conf or (not Ind_3_L_Conf and (candle_is_bullish_mzbu or candle_is_combi)))) and Ind_4_L_Conf and (Ind_6_Cont_BLATR_Rule ? true : Ind_4_L_Conf_ATR or Ind_4_L_Conf_STDEV)
shortCondition3 = strategy.position_size >= 0 and Ind_6_Look_For_Conts and Nau_EVZ_Avoid_USD_Conf and Ind_1_S_Conf and (Ind_6_Cont_EVZ_Rule ? true : Nau_EVZ_No_Entry_Rule_Conf) and (Ind_6_Cont_Method == "BLC" ? Ind_4_S_Trig_BLC : Ind_6_Cont_Method == "BLS" ? Ind_4_S_Trig_BLS : Ind_6_Cont_Method == "C1" ? Ind_1_S_Trig : Ind_6_Cont_Method == "Exit 1" ? Ind_5_L_Exit_1 : Ind_6_Cont_Method == "Exit 2" ? Ind_5_L_Exit_2 : Ind_6_Cont_Method == "Continuation" ? Ind_6_S_Trig : false) and (Ind_6_Cont_C2_Rule ? true : Ind_2_S_Conf) and (Ind_6_Cont_Vol_Rule ? true : (Ind_3_S_Conf or (not Ind_3_S_Conf and (candle_is_bearish_mzbu or candle_is_combi)))) and Ind_4_S_Conf and (Ind_6_Cont_BLATR_Rule ? true : Ind_4_S_Conf_ATR or Ind_4_L_Conf_STDEV)
plotshape(longCondition3,  color=color.new(color.green, 75), style=shape.circle,   location=location.bottom, size=size.tiny)
plotshape(shortCondition3, color=color.new(color.red, 75),   style=shape.circle, location=location.bottom, size=size.tiny)

// Define long and short variables
entryLong  = (longCondition1  or longCondition2 or longCondition3)  and dateWindow()
entryShort = (shortCondition1 or shortCondition2 or shortCondition3) and dateWindow()


// Store price and ATR of the most recent candle close
entryATR   = float(0.0)
entryPrice = float(0.0)
activate_tsl = bool(false)
activate_tsl2 = bool(false)

// When not in a trade, get the current ATR value. When in a trade, get the entry ATR value
entryATR   := strategy.position_size == 0 or entryLong or entryShort ? atr : entryATR[1]
// When not in a trade, get the current close price. When in a trade, get the entry price
entryPrice := strategy.position_size == 0 or entryLong or entryShort ? close : entryPrice[1]
// When not in a trade, set activate TSL to false. When in a trade, leave it alone
activate_tsl := strategy.position_size == 0 or entryLong or entryShort ? false : activate_tsl[1]
// When not in a trade, set activate TSL2 to false. When in a trade, leave it alone
activate_tsl2 := strategy.position_size == 0 or entryLong or entryShort ? false : activate_tsl2[1]



// Submit long and short orders based on entryLong/entryShort as defined above
if entryLong
    if Exit_Type == "Static"
        strategy.entry(id="Long Entry 1", direction=strategy.long, qty=positionSize)
    else
        strategy.entry(id="Long Entry 1", direction=strategy.long, qty=positionSize * 0.5)
        strategy.entry(id="Long Entry 2", direction=strategy.long, qty=positionSize * 0.5)

if entryShort
    if Exit_Type == "Static"
        strategy.entry(id="Short Entry 1", direction=strategy.short, qty=positionSize)
    else
        strategy.entry(id="Short Entry 1", direction=strategy.short, qty=positionSize * 0.5)
        strategy.entry(id="Short Entry 2", direction=strategy.short, qty=positionSize * 0.5)
//==============================================================================



//==============================================================================
// STATIC OR TRAILING STOP LOSS - Conditions
//==============================================================================
// ATR Trailing Stop Settings
do_atr_tsl = input.bool(title = "Use ATR Trailing Stop (TSL)?", defval = false, group = "ATR Trailing Stop Settings")
atr_tsl_calc_mode = input.string(title = "ATR TSL Calculation Mode", defval = "Use ATR value at the time of trade entry to calculate TSL levels", options = ["Use ATR value at the time of trade entry to calculate TSL levels", "Use the live ATR value to calculate TSL levels"], group = "ATR Trailing Stop Settings")
atr_tsl_min_distance = input.float(title = "After how many atr multiples in profit should the TSL be activated?", defval = 2, minval = 0, step = 0.5, group = "ATR Trailing Stop Settings")
atr_tsl_multiple = input.float(title = "ATR TSL Multiple", defval = 1.5, minval = 0, step = 0.5, group = "ATR Trailing Stop Settings")
do_atr_tsl2 = input.bool(title = "Use 2nd ATR TSL?", defval = false, group = "ATR Trailing Stop Settings")
atr_tsl2_min_distance = input.float(title = "After how many atr multiples in profit should the 2nd TSL be activated?", defval = 3, minval = 0, step = 0.5, group = "ATR Trailing Stop Settings")
atr_tsl2_multiple = input.float(title = "2nd ATR TSL Multiple", defval = 0.75, minval = 0, step = 0.25, group = "ATR Trailing Stop Settings")


// Calculate stop loss and take profit distance from entry (in price)
sl_pips = entryATR * atrMulti_Loss
tp_pips = entryATR * atrMulti_Profit

tsl_atr = atr_tsl_calc_mode == "Use ATR value at the time of trade entry to calculate TSL levels" ? entryATR : atr
tsl_min_distance_pips = entryATR * atr_tsl_min_distance
tsl_pips = tsl_atr * atr_tsl_multiple
tsl2_min_distance_pips = entryATR * atr_tsl2_min_distance
tsl2_pips = tsl_atr * atr_tsl2_multiple



// Calculate long entry SL and TP
long_sl_price = float(0.0) 
long_tp_price = float(0.0)

if Exit_Type == "Static"
    long_sl_price := entryPrice - sl_pips
    long_tp_price := entryPrice + tp_pips
else
    // Determine if price has closed at/above the tsl_min_distance_pips threshold
    if (close > (entryPrice + tsl_min_distance_pips)) and not activate_tsl
        activate_tsl := true
        
    // Determine if price has closed at/above the tsl2_min_distance_pips threshold
    if (close > (entryPrice + tsl2_min_distance_pips)) and not activate_tsl2
        activate_tsl2 := true

    if (do_atr_tsl or (Ind_5_Check_Exit and trailing_exit_type == "Split Exit: Exit indicator #1 + ATR Trailing Stop")) and activate_tsl
        long_sl_price := strategy.opentrades == 2 or entryLong ? entryPrice - sl_pips : strategy.opentrades == 1 ? math.max(do_atr_tsl2 and activate_tsl2 ? close - tsl2_pips : close - tsl_pips, nz(long_sl_price[1], 0), strategy.position_avg_price + sl_handicap) : na
    else
        long_sl_price := strategy.opentrades == 2 or entryLong ? entryPrice - sl_pips : strategy.opentrades == 1 ? strategy.position_avg_price + sl_handicap : na
    long_tp_price := entryPrice + tp_pips


// Calculate short entry SL and TP
short_sl_price = float(0.0)
short_tp_price = float(0.0)

if Exit_Type == "Static"
    short_sl_price := entryPrice + sl_pips
    short_tp_price := entryPrice - tp_pips
else
    // Determine if price has closed at/below the tsl_min_distance_pips threshold
    if (close < (entryPrice - tsl_min_distance_pips)) and not activate_tsl
        activate_tsl := true
    
    // Determine if price has closed at/above the tsl2_min_distance_pips threshold
    if (close < (entryPrice - tsl2_min_distance_pips)) and not activate_tsl2
        activate_tsl2 := true
    
    if (do_atr_tsl or (Ind_5_Check_Exit and trailing_exit_type == "Split Exit: Exit indicator #1 + ATR Trailing Stop")) and activate_tsl  
        short_sl_price := strategy.opentrades == 2 or entryShort ? entryPrice + sl_pips : strategy.opentrades == 1 ? math.min(do_atr_tsl2 and activate_tsl2 ? close + tsl2_pips : close + tsl_pips, nz(short_sl_price[1], 1000000000), strategy.position_avg_price - sl_handicap) : na
    else
        short_sl_price := strategy.opentrades == 2 or entryShort ? entryPrice + sl_pips : strategy.opentrades == 1 ? strategy.position_avg_price - sl_handicap : na
    short_tp_price := entryPrice - tp_pips

//------------------------------------------------------------------------------
// On-chart order brackets (entry price, sl price, tp price) coloring, plotting, and filling
//------------------------------------------------------------------------------
// Plot entry price level; hide when not in a trade
entry_line_plot = plot(strategy.position_size == 0 or entryLong or entryShort ? na : entryPrice, color=color.new(color.black, 50), style=plot.style_linebr, linewidth=1)

// Plot take profit and stop loss levels for long trades; hide when not in a trade
long_sl_line_plot = plot(strategy.position_size <= 0 or entryLong or entryShort ?                             na : long_sl_price, color=color.new(color.red, 20), style=plot.style_linebr, linewidth=2)
long_tp_line_plot = plot(strategy.position_size <= 0 or entryLong or entryShort or strategy.opentrades == 1 ? na : long_tp_price, color=color.new(color.green, 20), style=plot.style_linebr, linewidth=2)

// Plot take profit and stop loss levels for short trades; hide when not in a trade
short_sl_line_plot = plot(strategy.position_size >= 0 or entryLong or entryShort ?                             na : short_sl_price, color=color.new(color.red, 20), style=plot.style_linebr, linewidth=2)
short_tp_line_plot = plot(strategy.position_size >= 0 or entryLong or entryShort or strategy.opentrades == 1 ? na : short_tp_price, color=color.new(color.green, 20), style=plot.style_linebr, linewidth=2)
//------------------------------------------------------------------------------
//==============================================================================



//==============================================================================
// EXIT CONDITIONS (Static/TSL or Exit Indicator)  - Submit Orders
//==============================================================================

// Submit exit orders on static stop loss and take profit
if Exit_Type == "Static"
    // Long and short entry 1
    strategy.exit("TP/SL 1", "Long Entry 1", stop=long_sl_price, limit=long_tp_price)
    strategy.exit("TP/SL 1", "Short Entry 1", stop=short_sl_price, limit=short_tp_price)
    // Long and short entry 1
    strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_1_S_Trig)
    strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_1_L_Trig)

else
    if Nau_EVZ_Full_TP_Conf
        // Long and short entry 1
        strategy.exit("TP/SL 1", "Long Entry 1", stop=long_sl_price, limit=long_tp_price)
        strategy.exit("TP/SL 1", "Short Entry 1", stop=short_sl_price, limit=short_tp_price)
        // Long and short entry 2
        strategy.exit("TP/SL 2", "Long Entry 2", stop=long_sl_price, limit=long_tp_price)
        strategy.exit("TP/SL 2", "Short Entry 2", stop=short_sl_price, limit=short_tp_price)
    else
        // Long and short entry 1
        strategy.exit("TP/SL 1", "Long Entry 1", stop=long_sl_price, limit=long_tp_price)
        strategy.exit("TP/SL 1", "Short Entry 1", stop=short_sl_price, limit=short_tp_price)
        // Long and short entry 2
        strategy.exit("TP/SL 2", "Long Entry 2", stop=long_sl_price, limit=na)
        strategy.exit("TP/SL 2", "Short Entry 2", stop=short_sl_price, limit=na)
    
    // Submit exit orders on our selected exit type
    if trailing_exit_type == "Exit indicator #1"
        if Ind_5_Check_Exit_BLC
            if Ind_5_When_Exit_BLC == "Before 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_1 or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else if Ind_5_When_Exit_BLC == "After 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLC : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_1 or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLC : false) or Ind_1_L_Trig)
            else
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BLC or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or Ind_5_S_Exit_BLC or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BLC or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_1 or Ind_5_S_Exit_BLC or Ind_1_L_Trig)
        else if Ind_5_Check_Exit_BLS
            if Ind_5_When_Exit_BLS == "Before 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_1 or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else if Ind_5_When_Exit_BLS == "After 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_1 or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BLS or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or Ind_5_S_Exit_BLS or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BLS or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_1 or Ind_5_S_Exit_BLS or Ind_1_L_Trig)
        else
            // Long and short entry 1
            strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_1_S_Trig)
            strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or Ind_1_L_Trig)
            // Long and short entry 2
            strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_1 or Ind_1_S_Trig)
            strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_1 or Ind_1_L_Trig)
    else if trailing_exit_type == "Opposite C1 signal"
        if Ind_5_Check_Exit_BLC
            if Ind_5_When_Exit_BLC == "Before 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=(strategy.opentrades == 2 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=(strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 2 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else if Ind_5_When_Exit_BLC == "After 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_BLC : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_BLC : false) or Ind_1_L_Trig)
            else
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_BLC or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_BLC or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_BLC or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_BLC or Ind_1_L_Trig)
        else if Ind_5_Check_Exit_BLS
            if Ind_5_When_Exit_BLS == "Before 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=(strategy.opentrades == 2 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=(strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 2 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else if Ind_5_When_Exit_BLS == "After 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_BLS or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_BLS or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_5_L_Exit_BLS or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_5_S_Exit_BLS or Ind_1_L_Trig)
        else
            // Long and short entry 1
            strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_1_S_Trig or Ind_5_L_Exit_BL)
            strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_1_L_Trig or Ind_5_S_Exit_BL)
            // Long and short entry 2
            strategy.close("Long Entry 2",  comment="Exit Long 2",  when=Ind_1_S_Trig or Ind_5_L_Exit_BL)
            strategy.close("Short Entry 2", comment="Exit Short 2", when=Ind_1_L_Trig or Ind_5_S_Exit_BL)
    else if trailing_exit_type == "Split Exit: Exit indicator #1 + Opposite C1 Signal" or trailing_exit_type == "Split Exit: Exit indicator #1 + ATR Trailing Stop"
        if Ind_5_Check_Exit_BLC
            if Ind_5_When_Exit_BLC == "Before 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_1_S_Trig : Ind_5_L_Exit_1) or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_1_L_Trig : Ind_5_S_Exit_1) or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else if Ind_5_When_Exit_BLC == "After 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLC : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_1_S_Trig : Ind_5_L_Exit_1) or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_1_L_Trig : Ind_5_S_Exit_1) or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLC : false) or Ind_1_L_Trig)
            else
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BLC or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or Ind_5_S_Exit_BLC or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_1_S_Trig : Ind_5_L_Exit_1) or Ind_5_L_Exit_BLC or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_1_L_Trig : Ind_5_S_Exit_1) or Ind_5_S_Exit_BLC or Ind_1_L_Trig)
        else if Ind_5_Check_Exit_BLS
            if Ind_5_When_Exit_BLS == "Before 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_1_S_Trig : Ind_5_L_Exit_1) or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_1_L_Trig : Ind_5_S_Exit_1) or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else if Ind_5_When_Exit_BLS == "After 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_1_S_Trig : Ind_5_L_Exit_1) or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_1_L_Trig : Ind_5_S_Exit_1) or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BLS or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or Ind_5_S_Exit_BLS or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_1_S_Trig : Ind_5_L_Exit_1) or Ind_5_L_Exit_BLS or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_1_L_Trig : Ind_5_S_Exit_1) or Ind_5_S_Exit_BLS or Ind_1_L_Trig)
        else
            // Long and short entry 1
            strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BL or Ind_1_S_Trig)
            strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_L_Exit_1 or Ind_5_S_Exit_BL or Ind_1_L_Trig)
            // Long and short entry 2
            strategy.close("Long Entry 2",  comment="Exit Long 2",  when = (strategy.opentrades == 1 ? Ind_1_S_Trig : Ind_5_L_Exit_1) or Ind_5_L_Exit_BL or Ind_1_S_Trig)
            strategy.close("Short Entry 2", comment="Exit Short 2", when = (strategy.opentrades == 1 ? Ind_1_S_Trig : Ind_5_S_Exit_1) or Ind_5_S_Exit_BL or Ind_1_L_Trig)
    else if trailing_exit_type == "Split Exit: Exit indicator #1 + Exit indicator #2"
        if Ind_5_Check_Exit_BLC
            if Ind_5_When_Exit_BLC == "Before 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_2 : Ind_5_L_Exit_1) or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_2 : Ind_5_S_Exit_1) or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else if Ind_5_When_Exit_BLC == "After 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLC : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_2 : Ind_5_L_Exit_1) or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLC : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_2 : Ind_5_S_Exit_1) or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLC : false) or Ind_1_L_Trig)
            else
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BLC or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or Ind_5_S_Exit_BLC or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_2 : Ind_5_L_Exit_1) or Ind_5_L_Exit_BLC or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_2 : Ind_5_S_Exit_1) or Ind_5_S_Exit_BLC or Ind_1_L_Trig)
        else if Ind_5_Check_Exit_BLS
            if Ind_5_When_Exit_BLS == "Before 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_2 : Ind_5_L_Exit_1) or (strategy.opentrades == 2 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_2 : Ind_5_S_Exit_1) or (strategy.opentrades == 2 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else if Ind_5_When_Exit_BLS == "After 1xATR TP is reached"
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_2 : Ind_5_L_Exit_1) or (strategy.opentrades == 1 ? Ind_5_L_Exit_BLS : false) or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_2 : Ind_5_S_Exit_1) or (strategy.opentrades == 1 ? Ind_5_S_Exit_BLS : false) or Ind_1_L_Trig)
            else
                // Long and short entry 1
                strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BLS or Ind_1_S_Trig)
                strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_S_Exit_1 or Ind_5_S_Exit_BLS or Ind_1_L_Trig)
                // Long and short entry 2
                strategy.close("Long Entry 2",  comment="Exit Long 2",  when=(strategy.opentrades == 1 ? Ind_5_L_Exit_2 : Ind_5_L_Exit_1) or Ind_5_L_Exit_BLS or Ind_1_S_Trig)
                strategy.close("Short Entry 2", comment="Exit Short 2", when=(strategy.opentrades == 1 ? Ind_5_S_Exit_2 : Ind_5_S_Exit_1) or Ind_5_S_Exit_BLS or Ind_1_L_Trig)
        else
            // Long and short entry 1
            strategy.close("Long Entry 1",  comment="Exit Long 1",  when=Ind_5_L_Exit_1 or Ind_5_L_Exit_BL or Ind_1_S_Trig)
            strategy.close("Short Entry 1", comment="Exit Short 1", when=Ind_5_L_Exit_1 or Ind_5_S_Exit_BL or Ind_1_L_Trig)
            // Long and short entry 2
            strategy.close("Long Entry 2",  comment="Exit Long 2",  when = (strategy.opentrades == 1 ? Ind_5_L_Exit_2 : Ind_5_L_Exit_1) or Ind_5_L_Exit_BL or Ind_1_S_Trig)
            strategy.close("Short Entry 2", comment="Exit Short 2", when = (strategy.opentrades == 1 ? Ind_5_S_Exit_2 : Ind_5_S_Exit_1) or Ind_5_S_Exit_BL or Ind_1_L_Trig)
//==============================================================================



//==============================================================================
// PLOT LABELS / DASHBOARDS
//==============================================================================
labelText = "Postion Size: " + str.tostring(strategy.position_size) + "\nEntry Price: " + str.tostring(entryPrice) + "\nEntry ATR: " + str.tostring(entryATR) + "\nBridge Too Far 1.0: " + str.tostring(Count_Btf) + "\nBridge Too Far 2.0: " + str.tostring(Count_Btf2) + "\nContinuation: " + str.tostring(count_cont)
stratLabel = label.new(x=bar_index, y=na, text=labelText, yloc=yloc.abovebar, color=color.black, textcolor=color.rgb(227, 225, 214), style=label.style_label_down)
label.delete(stratLabel[1])  // Delete previous candles" labels
//==============================================================================
